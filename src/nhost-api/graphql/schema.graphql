schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
columns and relationships of "_enumtable.document_status"
"""
type _enumtable_document_status {
  comment: String

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!
  value: String!
}

"""
aggregated selection of "_enumtable.document_status"
"""
type _enumtable_document_status_aggregate {
  aggregate: _enumtable_document_status_aggregate_fields
  nodes: [_enumtable_document_status!]!
}

"""
aggregate fields of "_enumtable.document_status"
"""
type _enumtable_document_status_aggregate_fields {
  count(columns: [_enumtable_document_status_select_column!], distinct: Boolean): Int!
  max: _enumtable_document_status_max_fields
  min: _enumtable_document_status_min_fields
}

"""
Boolean expression to filter rows from the table "_enumtable.document_status". All fields are combined with a logical 'AND'.
"""
input _enumtable_document_status_bool_exp {
  _and: [_enumtable_document_status_bool_exp!]
  _not: _enumtable_document_status_bool_exp
  _or: [_enumtable_document_status_bool_exp!]
  comment: String_comparison_exp
  documents: documents_bool_exp
  documents_aggregate: documents_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "_enumtable.document_status"
"""
enum _enumtable_document_status_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  document_status_pkey
}

enum _enumtable_document_status_enum {
  """Document got approved"""
  APPROVED

  """Requires review"""
  PENDING

  """Document got rejected see reject reason"""
  REJECTED
}

"""
Boolean expression to compare columns of type "_enumtable_document_status_enum". All fields are combined with logical 'AND'.
"""
input _enumtable_document_status_enum_comparison_exp {
  _eq: _enumtable_document_status_enum
  _in: [_enumtable_document_status_enum!]
  _is_null: Boolean
  _neq: _enumtable_document_status_enum
  _nin: [_enumtable_document_status_enum!]
}

"""
input type for inserting data into table "_enumtable.document_status"
"""
input _enumtable_document_status_insert_input {
  comment: String
  documents: documents_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type _enumtable_document_status_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type _enumtable_document_status_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "_enumtable.document_status"
"""
type _enumtable_document_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [_enumtable_document_status!]!
}

"""
on_conflict condition type for table "_enumtable.document_status"
"""
input _enumtable_document_status_on_conflict {
  constraint: _enumtable_document_status_constraint!
  update_columns: [_enumtable_document_status_update_column!]! = []
  where: _enumtable_document_status_bool_exp
}

"""
Ordering options when selecting data from "_enumtable.document_status".
"""
input _enumtable_document_status_order_by {
  comment: order_by
  documents_aggregate: documents_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: _enumtable.document_status"""
input _enumtable_document_status_pk_columns_input {
  value: String!
}

"""
select columns of table "_enumtable.document_status"
"""
enum _enumtable_document_status_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "_enumtable.document_status"
"""
input _enumtable_document_status_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "_enumtable_document_status"
"""
input _enumtable_document_status_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: _enumtable_document_status_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input _enumtable_document_status_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "_enumtable.document_status"
"""
enum _enumtable_document_status_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input _enumtable_document_status_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: _enumtable_document_status_set_input

  """filter the rows which have to be updated"""
  where: _enumtable_document_status_bool_exp!
}

"""
columns and relationships of "_enumtable.document_type"
"""
type _enumtable_document_type {
  comment: String

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!
  value: String!
}

"""
aggregated selection of "_enumtable.document_type"
"""
type _enumtable_document_type_aggregate {
  aggregate: _enumtable_document_type_aggregate_fields
  nodes: [_enumtable_document_type!]!
}

"""
aggregate fields of "_enumtable.document_type"
"""
type _enumtable_document_type_aggregate_fields {
  count(columns: [_enumtable_document_type_select_column!], distinct: Boolean): Int!
  max: _enumtable_document_type_max_fields
  min: _enumtable_document_type_min_fields
}

"""
Boolean expression to filter rows from the table "_enumtable.document_type". All fields are combined with a logical 'AND'.
"""
input _enumtable_document_type_bool_exp {
  _and: [_enumtable_document_type_bool_exp!]
  _not: _enumtable_document_type_bool_exp
  _or: [_enumtable_document_type_bool_exp!]
  comment: String_comparison_exp
  documents: documents_bool_exp
  documents_aggregate: documents_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "_enumtable.document_type"
"""
enum _enumtable_document_type_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  document_type_pkey
}

enum _enumtable_document_type_enum {
  """The cover image of a club to show a preview in e.g. home screen"""
  CLUB_COVER

  """The logo image of a club to show a preview in e.g. home screen"""
  CLUB_LOGO

  """The fishing license of the user"""
  USER_FISHING_LICENSE
}

"""
Boolean expression to compare columns of type "_enumtable_document_type_enum". All fields are combined with logical 'AND'.
"""
input _enumtable_document_type_enum_comparison_exp {
  _eq: _enumtable_document_type_enum
  _in: [_enumtable_document_type_enum!]
  _is_null: Boolean
  _neq: _enumtable_document_type_enum
  _nin: [_enumtable_document_type_enum!]
}

"""
input type for inserting data into table "_enumtable.document_type"
"""
input _enumtable_document_type_insert_input {
  comment: String
  documents: documents_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type _enumtable_document_type_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type _enumtable_document_type_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "_enumtable.document_type"
"""
type _enumtable_document_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [_enumtable_document_type!]!
}

"""
on_conflict condition type for table "_enumtable.document_type"
"""
input _enumtable_document_type_on_conflict {
  constraint: _enumtable_document_type_constraint!
  update_columns: [_enumtable_document_type_update_column!]! = []
  where: _enumtable_document_type_bool_exp
}

"""Ordering options when selecting data from "_enumtable.document_type"."""
input _enumtable_document_type_order_by {
  comment: order_by
  documents_aggregate: documents_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: _enumtable.document_type"""
input _enumtable_document_type_pk_columns_input {
  value: String!
}

"""
select columns of table "_enumtable.document_type"
"""
enum _enumtable_document_type_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "_enumtable.document_type"
"""
input _enumtable_document_type_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "_enumtable_document_type"
"""
input _enumtable_document_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: _enumtable_document_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input _enumtable_document_type_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "_enumtable.document_type"
"""
enum _enumtable_document_type_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input _enumtable_document_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: _enumtable_document_type_set_input

  """filter the rows which have to be updated"""
  where: _enumtable_document_type_bool_exp!
}

"""
columns and relationships of "_enumtable.fish_type"
"""
type _enumtable_fish_type {
  comment: String
  type: String!
}

"""
aggregated selection of "_enumtable.fish_type"
"""
type _enumtable_fish_type_aggregate {
  aggregate: _enumtable_fish_type_aggregate_fields
  nodes: [_enumtable_fish_type!]!
}

"""
aggregate fields of "_enumtable.fish_type"
"""
type _enumtable_fish_type_aggregate_fields {
  count(columns: [_enumtable_fish_type_select_column!], distinct: Boolean): Int!
  max: _enumtable_fish_type_max_fields
  min: _enumtable_fish_type_min_fields
}

"""
Boolean expression to filter rows from the table "_enumtable.fish_type". All fields are combined with a logical 'AND'.
"""
input _enumtable_fish_type_bool_exp {
  _and: [_enumtable_fish_type_bool_exp!]
  _not: _enumtable_fish_type_bool_exp
  _or: [_enumtable_fish_type_bool_exp!]
  comment: String_comparison_exp
  type: String_comparison_exp
}

"""
unique or primary key constraints on table "_enumtable.fish_type"
"""
enum _enumtable_fish_type_constraint {
  """
  unique or primary key constraint on columns "type"
  """
  fish_type_pkey
}

"""
input type for inserting data into table "_enumtable.fish_type"
"""
input _enumtable_fish_type_insert_input {
  comment: String
  type: String
}

"""aggregate max on columns"""
type _enumtable_fish_type_max_fields {
  comment: String
  type: String
}

"""aggregate min on columns"""
type _enumtable_fish_type_min_fields {
  comment: String
  type: String
}

"""
response of any mutation on the table "_enumtable.fish_type"
"""
type _enumtable_fish_type_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [_enumtable_fish_type!]!
}

"""
on_conflict condition type for table "_enumtable.fish_type"
"""
input _enumtable_fish_type_on_conflict {
  constraint: _enumtable_fish_type_constraint!
  update_columns: [_enumtable_fish_type_update_column!]! = []
  where: _enumtable_fish_type_bool_exp
}

"""Ordering options when selecting data from "_enumtable.fish_type"."""
input _enumtable_fish_type_order_by {
  comment: order_by
  type: order_by
}

"""primary key columns input for table: _enumtable.fish_type"""
input _enumtable_fish_type_pk_columns_input {
  type: String!
}

"""
select columns of table "_enumtable.fish_type"
"""
enum _enumtable_fish_type_select_column {
  """column name"""
  comment

  """column name"""
  type
}

"""
input type for updating data in table "_enumtable.fish_type"
"""
input _enumtable_fish_type_set_input {
  comment: String
  type: String
}

"""
Streaming cursor of the table "_enumtable_fish_type"
"""
input _enumtable_fish_type_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: _enumtable_fish_type_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input _enumtable_fish_type_stream_cursor_value_input {
  comment: String
  type: String
}

"""
update columns of table "_enumtable.fish_type"
"""
enum _enumtable_fish_type_update_column {
  """column name"""
  comment

  """column name"""
  type
}

input _enumtable_fish_type_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: _enumtable_fish_type_set_input

  """filter the rows which have to be updated"""
  where: _enumtable_fish_type_bool_exp!
}

"""
columns and relationships of "_enumtable.report_reason"
"""
type _enumtable_report_reason {
  comment: String
  reason: String!
}

"""
aggregated selection of "_enumtable.report_reason"
"""
type _enumtable_report_reason_aggregate {
  aggregate: _enumtable_report_reason_aggregate_fields
  nodes: [_enumtable_report_reason!]!
}

"""
aggregate fields of "_enumtable.report_reason"
"""
type _enumtable_report_reason_aggregate_fields {
  count(columns: [_enumtable_report_reason_select_column!], distinct: Boolean): Int!
  max: _enumtable_report_reason_max_fields
  min: _enumtable_report_reason_min_fields
}

"""
Boolean expression to filter rows from the table "_enumtable.report_reason". All fields are combined with a logical 'AND'.
"""
input _enumtable_report_reason_bool_exp {
  _and: [_enumtable_report_reason_bool_exp!]
  _not: _enumtable_report_reason_bool_exp
  _or: [_enumtable_report_reason_bool_exp!]
  comment: String_comparison_exp
  reason: String_comparison_exp
}

"""
unique or primary key constraints on table "_enumtable.report_reason"
"""
enum _enumtable_report_reason_constraint {
  """
  unique or primary key constraint on columns "reason"
  """
  report_reason_pkey
}

enum _enumtable_report_reason_enum {
  HATE_SPEECH
  MISINFORMATION
  OTHER
  SEXUAL_CONTENT
  SPAM
  VIOLENCE
}

"""
Boolean expression to compare columns of type "_enumtable_report_reason_enum". All fields are combined with logical 'AND'.
"""
input _enumtable_report_reason_enum_comparison_exp {
  _eq: _enumtable_report_reason_enum
  _in: [_enumtable_report_reason_enum!]
  _is_null: Boolean
  _neq: _enumtable_report_reason_enum
  _nin: [_enumtable_report_reason_enum!]
}

"""
input type for inserting data into table "_enumtable.report_reason"
"""
input _enumtable_report_reason_insert_input {
  comment: String
  reason: String
}

"""aggregate max on columns"""
type _enumtable_report_reason_max_fields {
  comment: String
  reason: String
}

"""aggregate min on columns"""
type _enumtable_report_reason_min_fields {
  comment: String
  reason: String
}

"""
response of any mutation on the table "_enumtable.report_reason"
"""
type _enumtable_report_reason_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [_enumtable_report_reason!]!
}

"""
on_conflict condition type for table "_enumtable.report_reason"
"""
input _enumtable_report_reason_on_conflict {
  constraint: _enumtable_report_reason_constraint!
  update_columns: [_enumtable_report_reason_update_column!]! = []
  where: _enumtable_report_reason_bool_exp
}

"""Ordering options when selecting data from "_enumtable.report_reason"."""
input _enumtable_report_reason_order_by {
  comment: order_by
  reason: order_by
}

"""primary key columns input for table: _enumtable.report_reason"""
input _enumtable_report_reason_pk_columns_input {
  reason: String!
}

"""
select columns of table "_enumtable.report_reason"
"""
enum _enumtable_report_reason_select_column {
  """column name"""
  comment

  """column name"""
  reason
}

"""
input type for updating data in table "_enumtable.report_reason"
"""
input _enumtable_report_reason_set_input {
  comment: String
  reason: String
}

"""
Streaming cursor of the table "_enumtable_report_reason"
"""
input _enumtable_report_reason_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: _enumtable_report_reason_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input _enumtable_report_reason_stream_cursor_value_input {
  comment: String
  reason: String
}

"""
update columns of table "_enumtable.report_reason"
"""
enum _enumtable_report_reason_update_column {
  """column name"""
  comment

  """column name"""
  reason
}

input _enumtable_report_reason_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: _enumtable_report_reason_set_input

  """filter the rows which have to be updated"""
  where: _enumtable_report_reason_bool_exp!
}

"""
columns and relationships of "_enumtable.user_club_role"
"""
type _enumtable_user_club_role {
  comment: String
  role: String!
}

"""
aggregated selection of "_enumtable.user_club_role"
"""
type _enumtable_user_club_role_aggregate {
  aggregate: _enumtable_user_club_role_aggregate_fields
  nodes: [_enumtable_user_club_role!]!
}

"""
aggregate fields of "_enumtable.user_club_role"
"""
type _enumtable_user_club_role_aggregate_fields {
  count(columns: [_enumtable_user_club_role_select_column!], distinct: Boolean): Int!
  max: _enumtable_user_club_role_max_fields
  min: _enumtable_user_club_role_min_fields
}

"""
Boolean expression to filter rows from the table "_enumtable.user_club_role". All fields are combined with a logical 'AND'.
"""
input _enumtable_user_club_role_bool_exp {
  _and: [_enumtable_user_club_role_bool_exp!]
  _not: _enumtable_user_club_role_bool_exp
  _or: [_enumtable_user_club_role_bool_exp!]
  comment: String_comparison_exp
  role: String_comparison_exp
}

"""
unique or primary key constraints on table "_enumtable.user_club_role"
"""
enum _enumtable_user_club_role_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  user_club_role_pkey
}

enum _enumtable_user_club_role_enum {
  """
  The owner or any other person which should be granted full access to the club settings etc.
  """
  ADMIN

  """A normal member of the club"""
  USER
}

"""
Boolean expression to compare columns of type "_enumtable_user_club_role_enum". All fields are combined with logical 'AND'.
"""
input _enumtable_user_club_role_enum_comparison_exp {
  _eq: _enumtable_user_club_role_enum
  _in: [_enumtable_user_club_role_enum!]
  _is_null: Boolean
  _neq: _enumtable_user_club_role_enum
  _nin: [_enumtable_user_club_role_enum!]
}

"""
input type for inserting data into table "_enumtable.user_club_role"
"""
input _enumtable_user_club_role_insert_input {
  comment: String
  role: String
}

"""aggregate max on columns"""
type _enumtable_user_club_role_max_fields {
  comment: String
  role: String
}

"""aggregate min on columns"""
type _enumtable_user_club_role_min_fields {
  comment: String
  role: String
}

"""
response of any mutation on the table "_enumtable.user_club_role"
"""
type _enumtable_user_club_role_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [_enumtable_user_club_role!]!
}

"""
on_conflict condition type for table "_enumtable.user_club_role"
"""
input _enumtable_user_club_role_on_conflict {
  constraint: _enumtable_user_club_role_constraint!
  update_columns: [_enumtable_user_club_role_update_column!]! = []
  where: _enumtable_user_club_role_bool_exp
}

"""Ordering options when selecting data from "_enumtable.user_club_role"."""
input _enumtable_user_club_role_order_by {
  comment: order_by
  role: order_by
}

"""primary key columns input for table: _enumtable.user_club_role"""
input _enumtable_user_club_role_pk_columns_input {
  role: String!
}

"""
select columns of table "_enumtable.user_club_role"
"""
enum _enumtable_user_club_role_select_column {
  """column name"""
  comment

  """column name"""
  role
}

"""
input type for updating data in table "_enumtable.user_club_role"
"""
input _enumtable_user_club_role_set_input {
  comment: String
  role: String
}

"""
Streaming cursor of the table "_enumtable_user_club_role"
"""
input _enumtable_user_club_role_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: _enumtable_user_club_role_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input _enumtable_user_club_role_stream_cursor_value_input {
  comment: String
  role: String
}

"""
update columns of table "_enumtable.user_club_role"
"""
enum _enumtable_user_club_role_update_column {
  """column name"""
  comment

  """column name"""
  role
}

input _enumtable_user_club_role_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: _enumtable_user_club_role_set_input

  """filter the rows which have to be updated"""
  where: _enumtable_user_club_role_bool_exp!
}

type Aggregate {
  count: Int!
}

"""
Oauth requests, inserted before redirecting to the provider's site. Don't modify
its structure as Hasura Auth relies on it to function properly.
"""
type authProviderRequests {
  id: uuid!
  options(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_append_input {
  options: jsonb
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  options: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  provider_requests_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authProviderRequests_delete_at_path_input {
  options: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input authProviderRequests_delete_elem_input {
  options: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authProviderRequests_delete_key_input {
  options: String
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  options: jsonb
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  options: order_by
}

"""primary key columns input for table: auth.provider_requests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authProviderRequests_prepend_input {
  options: jsonb
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  options
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  options: jsonb
}

"""
Streaming cursor of the table "authProviderRequests"
"""
input authProviderRequests_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviderRequests_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviderRequests_stream_cursor_value_input {
  id: uuid
  options: jsonb
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  options
}

input authProviderRequests_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authProviderRequests_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authProviderRequests_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: authProviderRequests_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authProviderRequests_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authProviderRequests_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authProviderRequests_set_input

  """filter the rows which have to be updated"""
  where: authProviderRequests_bool_exp!
}

"""
List of available Oauth providers. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.providers"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
Streaming cursor of the table "authProviders"
"""
input authProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authProviders_stream_cursor_value_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

input authProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authProviders_set_input

  """filter the rows which have to be updated"""
  where: authProviders_bool_exp!
}

"""
User refresh tokens. Hasura auth uses them to rotate new access tokens as long
as the refresh token is not expired. Don't modify its structure as Hasura Auth
relies on it to function properly.
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  id: uuid!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

input authRefreshTokens_aggregate_bool_exp {
  count: authRefreshTokens_aggregate_bool_exp_count
}

input authRefreshTokens_aggregate_bool_exp_count {
  arguments: [authRefreshTokens_select_column!]
  distinct: Boolean
  filter: authRefreshTokens_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input authRefreshTokens_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  refreshTokenHash: String_comparison_exp
  type: authRefreshTokenTypes_enum_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  refresh_tokens_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input authRefreshTokens_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input authRefreshTokens_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input authRefreshTokens_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  refreshTokenHash: String
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  refreshTokenHash: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  id: order_by
  metadata: order_by
  refreshTokenHash: order_by
  type: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.refresh_tokens"""
input authRefreshTokens_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input authRefreshTokens_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  refreshTokenHash

  """column name"""
  type

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
Streaming cursor of the table "authRefreshTokens"
"""
input authRefreshTokens_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokens_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokens_stream_cursor_value_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  id: uuid
  metadata: jsonb
  refreshTokenHash: String
  type: authRefreshTokenTypes_enum
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  refreshTokenHash

  """column name"""
  type

  """column name"""
  userId
}

input authRefreshTokens_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: authRefreshTokens_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: authRefreshTokens_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: authRefreshTokens_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: authRefreshTokens_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: authRefreshTokens_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokens_set_input

  """filter the rows which have to be updated"""
  where: authRefreshTokens_bool_exp!
}

"""
columns and relationships of "auth.refresh_token_types"
"""
type authRefreshTokenTypes {
  comment: String

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!
  value: String!
}

"""
aggregated selection of "auth.refresh_token_types"
"""
type authRefreshTokenTypes_aggregate {
  aggregate: authRefreshTokenTypes_aggregate_fields
  nodes: [authRefreshTokenTypes!]!
}

"""
aggregate fields of "auth.refresh_token_types"
"""
type authRefreshTokenTypes_aggregate_fields {
  count(columns: [authRefreshTokenTypes_select_column!], distinct: Boolean): Int!
  max: authRefreshTokenTypes_max_fields
  min: authRefreshTokenTypes_min_fields
}

"""
Boolean expression to filter rows from the table "auth.refresh_token_types". All fields are combined with a logical 'AND'.
"""
input authRefreshTokenTypes_bool_exp {
  _and: [authRefreshTokenTypes_bool_exp!]
  _not: authRefreshTokenTypes_bool_exp
  _or: [authRefreshTokenTypes_bool_exp!]
  comment: String_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_constraint {
  """
  unique or primary key constraint on columns "value"
  """
  refresh_token_types_pkey
}

enum authRefreshTokenTypes_enum {
  """Personal access token"""
  pat

  """Regular refresh token"""
  regular
}

"""
Boolean expression to compare columns of type "authRefreshTokenTypes_enum". All fields are combined with logical 'AND'.
"""
input authRefreshTokenTypes_enum_comparison_exp {
  _eq: authRefreshTokenTypes_enum
  _in: [authRefreshTokenTypes_enum!]
  _is_null: Boolean
  _neq: authRefreshTokenTypes_enum
  _nin: [authRefreshTokenTypes_enum!]
}

"""
input type for inserting data into table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_insert_input {
  comment: String
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type authRefreshTokenTypes_max_fields {
  comment: String
  value: String
}

"""aggregate min on columns"""
type authRefreshTokenTypes_min_fields {
  comment: String
  value: String
}

"""
response of any mutation on the table "auth.refresh_token_types"
"""
type authRefreshTokenTypes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokenTypes!]!
}

"""
on_conflict condition type for table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_on_conflict {
  constraint: authRefreshTokenTypes_constraint!
  update_columns: [authRefreshTokenTypes_update_column!]! = []
  where: authRefreshTokenTypes_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_token_types"."""
input authRefreshTokenTypes_order_by {
  comment: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  value: order_by
}

"""primary key columns input for table: auth.refresh_token_types"""
input authRefreshTokenTypes_pk_columns_input {
  value: String!
}

"""
select columns of table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_select_column {
  """column name"""
  comment

  """column name"""
  value
}

"""
input type for updating data in table "auth.refresh_token_types"
"""
input authRefreshTokenTypes_set_input {
  comment: String
  value: String
}

"""
Streaming cursor of the table "authRefreshTokenTypes"
"""
input authRefreshTokenTypes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRefreshTokenTypes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRefreshTokenTypes_stream_cursor_value_input {
  comment: String
  value: String
}

"""
update columns of table "auth.refresh_token_types"
"""
enum authRefreshTokenTypes_update_column {
  """column name"""
  comment

  """column name"""
  value
}

input authRefreshTokenTypes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRefreshTokenTypes_set_input

  """filter the rows which have to be updated"""
  where: authRefreshTokenTypes_bool_exp!
}

"""
Persistent Hasura roles for users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  userRoles_aggregate: authUserRoles_aggregate_bool_exp
  usersByDefaultRole: users_bool_exp
  usersByDefaultRole_aggregate: users_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """
  unique or primary key constraint on columns "role"
  """
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: auth.roles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
Streaming cursor of the table "authRoles"
"""
input authRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authRoles_stream_cursor_value_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

input authRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authRoles_set_input

  """filter the rows which have to be updated"""
  where: authRoles_bool_exp!
}

"""
Active providers for a given user. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

input authUserProviders_aggregate_bool_exp {
  count: authUserProviders_aggregate_bool_exp_count
}

input authUserProviders_aggregate_bool_exp_count {
  arguments: [authUserProviders_select_column!]
  distinct: Boolean
  filter: authUserProviders_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_providers_pkey

  """
  unique or primary key constraint on columns "provider_user_id", "provider_id"
  """
  user_providers_provider_id_provider_user_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_providers"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
Streaming cursor of the table "authUserProviders"
"""
input authUserProviders_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserProviders_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserProviders_stream_cursor_value_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

input authUserProviders_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserProviders_set_input

  """filter the rows which have to be updated"""
  where: authUserProviders_bool_exp!
}

"""
Roles of users. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

input authUserRoles_aggregate_bool_exp {
  count: authUserRoles_aggregate_bool_exp_count
}

input authUserRoles_aggregate_bool_exp_count {
  arguments: [authUserRoles_select_column!]
  distinct: Boolean
  filter: authUserRoles_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_roles_pkey

  """
  unique or primary key constraint on columns "user_id", "role"
  """
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_roles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
Streaming cursor of the table "authUserRoles"
"""
input authUserRoles_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserRoles_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserRoles_stream_cursor_value_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

input authUserRoles_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: authUserRoles_set_input

  """filter the rows which have to be updated"""
  where: authUserRoles_bool_exp!
}

"""
User webauthn security keys. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type authUserSecurityKeys {
  counter: bigint!
  credentialId: String!
  credentialPublicKey: bytea
  id: uuid!
  nickname: String
  transports: String!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate {
  aggregate: authUserSecurityKeys_aggregate_fields
  nodes: [authUserSecurityKeys!]!
}

input authUserSecurityKeys_aggregate_bool_exp {
  count: authUserSecurityKeys_aggregate_bool_exp_count
}

input authUserSecurityKeys_aggregate_bool_exp_count {
  arguments: [authUserSecurityKeys_select_column!]
  distinct: Boolean
  filter: authUserSecurityKeys_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.user_security_keys"
"""
type authUserSecurityKeys_aggregate_fields {
  avg: authUserSecurityKeys_avg_fields
  count(columns: [authUserSecurityKeys_select_column!], distinct: Boolean): Int!
  max: authUserSecurityKeys_max_fields
  min: authUserSecurityKeys_min_fields
  stddev: authUserSecurityKeys_stddev_fields
  stddev_pop: authUserSecurityKeys_stddev_pop_fields
  stddev_samp: authUserSecurityKeys_stddev_samp_fields
  sum: authUserSecurityKeys_sum_fields
  var_pop: authUserSecurityKeys_var_pop_fields
  var_samp: authUserSecurityKeys_var_samp_fields
  variance: authUserSecurityKeys_variance_fields
}

"""
order by aggregate values of table "auth.user_security_keys"
"""
input authUserSecurityKeys_aggregate_order_by {
  avg: authUserSecurityKeys_avg_order_by
  count: order_by
  max: authUserSecurityKeys_max_order_by
  min: authUserSecurityKeys_min_order_by
  stddev: authUserSecurityKeys_stddev_order_by
  stddev_pop: authUserSecurityKeys_stddev_pop_order_by
  stddev_samp: authUserSecurityKeys_stddev_samp_order_by
  sum: authUserSecurityKeys_sum_order_by
  var_pop: authUserSecurityKeys_var_pop_order_by
  var_samp: authUserSecurityKeys_var_samp_order_by
  variance: authUserSecurityKeys_variance_order_by
}

"""
input type for inserting array relation for remote table "auth.user_security_keys"
"""
input authUserSecurityKeys_arr_rel_insert_input {
  data: [authUserSecurityKeys_insert_input!]!

  """upsert condition"""
  on_conflict: authUserSecurityKeys_on_conflict
}

"""aggregate avg on columns"""
type authUserSecurityKeys_avg_fields {
  counter: Float
}

"""
order by avg() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_avg_order_by {
  counter: order_by
}

"""
Boolean expression to filter rows from the table "auth.user_security_keys". All fields are combined with a logical 'AND'.
"""
input authUserSecurityKeys_bool_exp {
  _and: [authUserSecurityKeys_bool_exp!]
  _not: authUserSecurityKeys_bool_exp
  _or: [authUserSecurityKeys_bool_exp!]
  counter: bigint_comparison_exp
  credentialId: String_comparison_exp
  credentialPublicKey: bytea_comparison_exp
  id: uuid_comparison_exp
  nickname: String_comparison_exp
  transports: String_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_security_keys"
"""
enum authUserSecurityKeys_constraint {
  """
  unique or primary key constraint on columns "credential_id"
  """
  user_security_key_credential_id_key

  """
  unique or primary key constraint on columns "id"
  """
  user_security_keys_pkey
}

"""
input type for incrementing numeric columns in table "auth.user_security_keys"
"""
input authUserSecurityKeys_inc_input {
  counter: bigint
}

"""
input type for inserting data into table "auth.user_security_keys"
"""
input authUserSecurityKeys_insert_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserSecurityKeys_max_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_max_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserSecurityKeys_min_fields {
  counter: bigint
  credentialId: String
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_min_order_by {
  counter: order_by
  credentialId: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_security_keys"
"""
type authUserSecurityKeys_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserSecurityKeys!]!
}

"""
on_conflict condition type for table "auth.user_security_keys"
"""
input authUserSecurityKeys_on_conflict {
  constraint: authUserSecurityKeys_constraint!
  update_columns: [authUserSecurityKeys_update_column!]! = []
  where: authUserSecurityKeys_bool_exp
}

"""Ordering options when selecting data from "auth.user_security_keys"."""
input authUserSecurityKeys_order_by {
  counter: order_by
  credentialId: order_by
  credentialPublicKey: order_by
  id: order_by
  nickname: order_by
  transports: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: auth.user_security_keys"""
input authUserSecurityKeys_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_select_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_security_keys"
"""
input authUserSecurityKeys_set_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate stddev on columns"""
type authUserSecurityKeys_stddev_fields {
  counter: Float
}

"""
order by stddev() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_order_by {
  counter: order_by
}

"""aggregate stddev_pop on columns"""
type authUserSecurityKeys_stddev_pop_fields {
  counter: Float
}

"""
order by stddev_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_pop_order_by {
  counter: order_by
}

"""aggregate stddev_samp on columns"""
type authUserSecurityKeys_stddev_samp_fields {
  counter: Float
}

"""
order by stddev_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_stddev_samp_order_by {
  counter: order_by
}

"""
Streaming cursor of the table "authUserSecurityKeys"
"""
input authUserSecurityKeys_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: authUserSecurityKeys_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input authUserSecurityKeys_stream_cursor_value_input {
  counter: bigint
  credentialId: String
  credentialPublicKey: bytea
  id: uuid
  nickname: String
  transports: String
  userId: uuid
}

"""aggregate sum on columns"""
type authUserSecurityKeys_sum_fields {
  counter: bigint
}

"""
order by sum() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_sum_order_by {
  counter: order_by
}

"""
update columns of table "auth.user_security_keys"
"""
enum authUserSecurityKeys_update_column {
  """column name"""
  counter

  """column name"""
  credentialId

  """column name"""
  credentialPublicKey

  """column name"""
  id

  """column name"""
  nickname

  """column name"""
  transports

  """column name"""
  userId
}

input authUserSecurityKeys_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: authUserSecurityKeys_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: authUserSecurityKeys_set_input

  """filter the rows which have to be updated"""
  where: authUserSecurityKeys_bool_exp!
}

"""aggregate var_pop on columns"""
type authUserSecurityKeys_var_pop_fields {
  counter: Float
}

"""
order by var_pop() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_pop_order_by {
  counter: order_by
}

"""aggregate var_samp on columns"""
type authUserSecurityKeys_var_samp_fields {
  counter: Float
}

"""
order by var_samp() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_var_samp_order_by {
  counter: order_by
}

"""aggregate variance on columns"""
type authUserSecurityKeys_variance_fields {
  counter: Float
}

"""
order by variance() on columns of table "auth.user_security_keys"
"""
input authUserSecurityKeys_variance_order_by {
  counter: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  files_aggregate: files_aggregate_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: storage.buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Streaming cursor of the table "buckets"
"""
input buckets_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: buckets_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input buckets_stream_cursor_value_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

input buckets_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: buckets_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: buckets_set_input

  """filter the rows which have to be updated"""
  where: buckets_bool_exp!
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

scalar bytea

"""
Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'.
"""
input bytea_comparison_exp {
  _eq: bytea
  _gt: bytea
  _gte: bytea
  _in: [bytea!]
  _is_null: Boolean
  _lt: bytea
  _lte: bytea
  _neq: bytea
  _nin: [bytea!]
}

"""
columns and relationships of "catches"
"""
type catches {
  datetime: timestamptz!
  fish_type: String!

  """An object relationship"""
  fishing_day: fishing_days
  fishing_day_id: uuid!
  id: uuid!
  image_id: uuid
  length: numeric!
  user_id: uuid!
  weight: numeric!
}

"""
aggregated selection of "catches"
"""
type catches_aggregate {
  aggregate: catches_aggregate_fields
  nodes: [catches!]!
}

input catches_aggregate_bool_exp {
  count: catches_aggregate_bool_exp_count
}

input catches_aggregate_bool_exp_count {
  arguments: [catches_select_column!]
  distinct: Boolean
  filter: catches_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "catches"
"""
type catches_aggregate_fields {
  avg: catches_avg_fields
  count(columns: [catches_select_column!], distinct: Boolean): Int!
  max: catches_max_fields
  min: catches_min_fields
  stddev: catches_stddev_fields
  stddev_pop: catches_stddev_pop_fields
  stddev_samp: catches_stddev_samp_fields
  sum: catches_sum_fields
  var_pop: catches_var_pop_fields
  var_samp: catches_var_samp_fields
  variance: catches_variance_fields
}

"""
order by aggregate values of table "catches"
"""
input catches_aggregate_order_by {
  avg: catches_avg_order_by
  count: order_by
  max: catches_max_order_by
  min: catches_min_order_by
  stddev: catches_stddev_order_by
  stddev_pop: catches_stddev_pop_order_by
  stddev_samp: catches_stddev_samp_order_by
  sum: catches_sum_order_by
  var_pop: catches_var_pop_order_by
  var_samp: catches_var_samp_order_by
  variance: catches_variance_order_by
}

"""
input type for inserting array relation for remote table "catches"
"""
input catches_arr_rel_insert_input {
  data: [catches_insert_input!]!

  """upsert condition"""
  on_conflict: catches_on_conflict
}

"""aggregate avg on columns"""
type catches_avg_fields {
  length: Float
  weight: Float
}

"""
order by avg() on columns of table "catches"
"""
input catches_avg_order_by {
  length: order_by
  weight: order_by
}

"""
Boolean expression to filter rows from the table "catches". All fields are combined with a logical 'AND'.
"""
input catches_bool_exp {
  _and: [catches_bool_exp!]
  _not: catches_bool_exp
  _or: [catches_bool_exp!]
  datetime: timestamptz_comparison_exp
  fish_type: String_comparison_exp
  fishing_day: fishing_days_bool_exp
  fishing_day_id: uuid_comparison_exp
  id: uuid_comparison_exp
  image_id: uuid_comparison_exp
  length: numeric_comparison_exp
  user_id: uuid_comparison_exp
  weight: numeric_comparison_exp
}

"""
unique or primary key constraints on table "catches"
"""
enum catches_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  catches_pkey
}

"""
input type for incrementing numeric columns in table "catches"
"""
input catches_inc_input {
  length: numeric
  weight: numeric
}

"""
input type for inserting data into table "catches"
"""
input catches_insert_input {
  datetime: timestamptz
  fish_type: String
  fishing_day: fishing_days_obj_rel_insert_input
  fishing_day_id: uuid
  id: uuid
  image_id: uuid
  length: numeric
  user_id: uuid
  weight: numeric
}

"""aggregate max on columns"""
type catches_max_fields {
  datetime: timestamptz
  fish_type: String
  fishing_day_id: uuid
  id: uuid
  image_id: uuid
  length: numeric
  user_id: uuid
  weight: numeric
}

"""
order by max() on columns of table "catches"
"""
input catches_max_order_by {
  datetime: order_by
  fish_type: order_by
  fishing_day_id: order_by
  id: order_by
  image_id: order_by
  length: order_by
  user_id: order_by
  weight: order_by
}

"""aggregate min on columns"""
type catches_min_fields {
  datetime: timestamptz
  fish_type: String
  fishing_day_id: uuid
  id: uuid
  image_id: uuid
  length: numeric
  user_id: uuid
  weight: numeric
}

"""
order by min() on columns of table "catches"
"""
input catches_min_order_by {
  datetime: order_by
  fish_type: order_by
  fishing_day_id: order_by
  id: order_by
  image_id: order_by
  length: order_by
  user_id: order_by
  weight: order_by
}

"""
response of any mutation on the table "catches"
"""
type catches_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [catches!]!
}

"""
on_conflict condition type for table "catches"
"""
input catches_on_conflict {
  constraint: catches_constraint!
  update_columns: [catches_update_column!]! = []
  where: catches_bool_exp
}

"""Ordering options when selecting data from "catches"."""
input catches_order_by {
  datetime: order_by
  fish_type: order_by
  fishing_day: fishing_days_order_by
  fishing_day_id: order_by
  id: order_by
  image_id: order_by
  length: order_by
  user_id: order_by
  weight: order_by
}

"""primary key columns input for table: catches"""
input catches_pk_columns_input {
  id: uuid!
}

"""
select columns of table "catches"
"""
enum catches_select_column {
  """column name"""
  datetime

  """column name"""
  fish_type

  """column name"""
  fishing_day_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  length

  """column name"""
  user_id

  """column name"""
  weight
}

"""
input type for updating data in table "catches"
"""
input catches_set_input {
  datetime: timestamptz
  fish_type: String
  fishing_day_id: uuid
  id: uuid
  image_id: uuid
  length: numeric
  user_id: uuid
  weight: numeric
}

"""aggregate stddev on columns"""
type catches_stddev_fields {
  length: Float
  weight: Float
}

"""
order by stddev() on columns of table "catches"
"""
input catches_stddev_order_by {
  length: order_by
  weight: order_by
}

"""aggregate stddev_pop on columns"""
type catches_stddev_pop_fields {
  length: Float
  weight: Float
}

"""
order by stddev_pop() on columns of table "catches"
"""
input catches_stddev_pop_order_by {
  length: order_by
  weight: order_by
}

"""aggregate stddev_samp on columns"""
type catches_stddev_samp_fields {
  length: Float
  weight: Float
}

"""
order by stddev_samp() on columns of table "catches"
"""
input catches_stddev_samp_order_by {
  length: order_by
  weight: order_by
}

"""
Streaming cursor of the table "catches"
"""
input catches_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: catches_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input catches_stream_cursor_value_input {
  datetime: timestamptz
  fish_type: String
  fishing_day_id: uuid
  id: uuid
  image_id: uuid
  length: numeric
  user_id: uuid
  weight: numeric
}

"""aggregate sum on columns"""
type catches_sum_fields {
  length: numeric
  weight: numeric
}

"""
order by sum() on columns of table "catches"
"""
input catches_sum_order_by {
  length: order_by
  weight: order_by
}

"""
update columns of table "catches"
"""
enum catches_update_column {
  """column name"""
  datetime

  """column name"""
  fish_type

  """column name"""
  fishing_day_id

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  length

  """column name"""
  user_id

  """column name"""
  weight
}

input catches_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: catches_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: catches_set_input

  """filter the rows which have to be updated"""
  where: catches_bool_exp!
}

"""aggregate var_pop on columns"""
type catches_var_pop_fields {
  length: Float
  weight: Float
}

"""
order by var_pop() on columns of table "catches"
"""
input catches_var_pop_order_by {
  length: order_by
  weight: order_by
}

"""aggregate var_samp on columns"""
type catches_var_samp_fields {
  length: Float
  weight: Float
}

"""
order by var_samp() on columns of table "catches"
"""
input catches_var_samp_order_by {
  length: order_by
  weight: order_by
}

"""aggregate variance on columns"""
type catches_variance_fields {
  length: Float
  weight: Float
}

"""
order by variance() on columns of table "catches"
"""
input catches_variance_order_by {
  length: order_by
  weight: order_by
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""
columns and relationships of "club_documents"
"""
type club_documents {
  """An object relationship"""
  club: clubs!
  club_id: uuid!
  document_status: _enumtable_document_status_enum!
  document_type: _enumtable_document_type_enum!

  """An object relationship"""
  file: files!
  file_id: uuid!
  id: uuid!
  rejected_reason: String
  version: bigint!
}

"""
aggregated selection of "club_documents"
"""
type club_documents_aggregate {
  aggregate: club_documents_aggregate_fields
  nodes: [club_documents!]!
}

input club_documents_aggregate_bool_exp {
  count: club_documents_aggregate_bool_exp_count
}

input club_documents_aggregate_bool_exp_count {
  arguments: [club_documents_select_column!]
  distinct: Boolean
  filter: club_documents_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "club_documents"
"""
type club_documents_aggregate_fields {
  avg: club_documents_avg_fields
  count(columns: [club_documents_select_column!], distinct: Boolean): Int!
  max: club_documents_max_fields
  min: club_documents_min_fields
  stddev: club_documents_stddev_fields
  stddev_pop: club_documents_stddev_pop_fields
  stddev_samp: club_documents_stddev_samp_fields
  sum: club_documents_sum_fields
  var_pop: club_documents_var_pop_fields
  var_samp: club_documents_var_samp_fields
  variance: club_documents_variance_fields
}

"""
order by aggregate values of table "club_documents"
"""
input club_documents_aggregate_order_by {
  avg: club_documents_avg_order_by
  count: order_by
  max: club_documents_max_order_by
  min: club_documents_min_order_by
  stddev: club_documents_stddev_order_by
  stddev_pop: club_documents_stddev_pop_order_by
  stddev_samp: club_documents_stddev_samp_order_by
  sum: club_documents_sum_order_by
  var_pop: club_documents_var_pop_order_by
  var_samp: club_documents_var_samp_order_by
  variance: club_documents_variance_order_by
}

"""
input type for inserting array relation for remote table "club_documents"
"""
input club_documents_arr_rel_insert_input {
  data: [club_documents_insert_input!]!

  """upsert condition"""
  on_conflict: club_documents_on_conflict
}

"""aggregate avg on columns"""
type club_documents_avg_fields {
  version: Float
}

"""
order by avg() on columns of table "club_documents"
"""
input club_documents_avg_order_by {
  version: order_by
}

"""
Boolean expression to filter rows from the table "club_documents". All fields are combined with a logical 'AND'.
"""
input club_documents_bool_exp {
  _and: [club_documents_bool_exp!]
  _not: club_documents_bool_exp
  _or: [club_documents_bool_exp!]
  club: clubs_bool_exp
  club_id: uuid_comparison_exp
  document_status: _enumtable_document_status_enum_comparison_exp
  document_type: _enumtable_document_type_enum_comparison_exp
  file: files_bool_exp
  file_id: uuid_comparison_exp
  id: uuid_comparison_exp
  rejected_reason: String_comparison_exp
  version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "club_documents"
"""
enum club_documents_constraint {
  """
  unique or primary key constraint on columns "file_id"
  """
  club_documents_file_id_key

  """
  unique or primary key constraint on columns "id"
  """
  club_documents_pkey
}

"""
input type for incrementing numeric columns in table "club_documents"
"""
input club_documents_inc_input {
  version: bigint
}

"""
input type for inserting data into table "club_documents"
"""
input club_documents_insert_input {
  club: clubs_obj_rel_insert_input
  club_id: uuid
  document_status: _enumtable_document_status_enum
  document_type: _enumtable_document_type_enum
  file: files_obj_rel_insert_input
  file_id: uuid
  id: uuid
  rejected_reason: String
  version: bigint
}

"""aggregate max on columns"""
type club_documents_max_fields {
  club_id: uuid
  file_id: uuid
  id: uuid
  rejected_reason: String
  version: bigint
}

"""
order by max() on columns of table "club_documents"
"""
input club_documents_max_order_by {
  club_id: order_by
  file_id: order_by
  id: order_by
  rejected_reason: order_by
  version: order_by
}

"""aggregate min on columns"""
type club_documents_min_fields {
  club_id: uuid
  file_id: uuid
  id: uuid
  rejected_reason: String
  version: bigint
}

"""
order by min() on columns of table "club_documents"
"""
input club_documents_min_order_by {
  club_id: order_by
  file_id: order_by
  id: order_by
  rejected_reason: order_by
  version: order_by
}

"""
response of any mutation on the table "club_documents"
"""
type club_documents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [club_documents!]!
}

"""
input type for inserting object relation for remote table "club_documents"
"""
input club_documents_obj_rel_insert_input {
  data: club_documents_insert_input!

  """upsert condition"""
  on_conflict: club_documents_on_conflict
}

"""
on_conflict condition type for table "club_documents"
"""
input club_documents_on_conflict {
  constraint: club_documents_constraint!
  update_columns: [club_documents_update_column!]! = []
  where: club_documents_bool_exp
}

"""Ordering options when selecting data from "club_documents"."""
input club_documents_order_by {
  club: clubs_order_by
  club_id: order_by
  document_status: order_by
  document_type: order_by
  file: files_order_by
  file_id: order_by
  id: order_by
  rejected_reason: order_by
  version: order_by
}

"""primary key columns input for table: club_documents"""
input club_documents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "club_documents"
"""
enum club_documents_select_column {
  """column name"""
  club_id

  """column name"""
  document_status

  """column name"""
  document_type

  """column name"""
  file_id

  """column name"""
  id

  """column name"""
  rejected_reason

  """column name"""
  version
}

"""
input type for updating data in table "club_documents"
"""
input club_documents_set_input {
  club_id: uuid
  document_status: _enumtable_document_status_enum
  document_type: _enumtable_document_type_enum
  file_id: uuid
  id: uuid
  rejected_reason: String
  version: bigint
}

"""aggregate stddev on columns"""
type club_documents_stddev_fields {
  version: Float
}

"""
order by stddev() on columns of table "club_documents"
"""
input club_documents_stddev_order_by {
  version: order_by
}

"""aggregate stddev_pop on columns"""
type club_documents_stddev_pop_fields {
  version: Float
}

"""
order by stddev_pop() on columns of table "club_documents"
"""
input club_documents_stddev_pop_order_by {
  version: order_by
}

"""aggregate stddev_samp on columns"""
type club_documents_stddev_samp_fields {
  version: Float
}

"""
order by stddev_samp() on columns of table "club_documents"
"""
input club_documents_stddev_samp_order_by {
  version: order_by
}

"""
Streaming cursor of the table "club_documents"
"""
input club_documents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_documents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_documents_stream_cursor_value_input {
  club_id: uuid
  document_status: _enumtable_document_status_enum
  document_type: _enumtable_document_type_enum
  file_id: uuid
  id: uuid
  rejected_reason: String
  version: bigint
}

"""aggregate sum on columns"""
type club_documents_sum_fields {
  version: bigint
}

"""
order by sum() on columns of table "club_documents"
"""
input club_documents_sum_order_by {
  version: order_by
}

"""
update columns of table "club_documents"
"""
enum club_documents_update_column {
  """column name"""
  club_id

  """column name"""
  document_status

  """column name"""
  document_type

  """column name"""
  file_id

  """column name"""
  id

  """column name"""
  rejected_reason

  """column name"""
  version
}

input club_documents_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: club_documents_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: club_documents_set_input

  """filter the rows which have to be updated"""
  where: club_documents_bool_exp!
}

"""aggregate var_pop on columns"""
type club_documents_var_pop_fields {
  version: Float
}

"""
order by var_pop() on columns of table "club_documents"
"""
input club_documents_var_pop_order_by {
  version: order_by
}

"""aggregate var_samp on columns"""
type club_documents_var_samp_fields {
  version: Float
}

"""
order by var_samp() on columns of table "club_documents"
"""
input club_documents_var_samp_order_by {
  version: order_by
}

"""aggregate variance on columns"""
type club_documents_variance_fields {
  version: Float
}

"""
order by variance() on columns of table "club_documents"
"""
input club_documents_variance_order_by {
  version: order_by
}

"""
columns and relationships of "club_feed"
"""
type club_feed {
  body: String!

  """An object relationship"""
  club: clubs!
  club_id: uuid!

  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int
  datetime: timestamptz!
  id: uuid!
  image_ids: [uuid!]!

  """
  A computed field, executes function "feed_liked_by_user"
  """
  liked_by_user: Boolean

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
  title: String!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "club_feed"
"""
type club_feed_aggregate {
  aggregate: club_feed_aggregate_fields
  nodes: [club_feed!]!
}

"""
aggregate fields of "club_feed"
"""
type club_feed_aggregate_fields {
  avg: club_feed_avg_fields
  count(columns: [club_feed_select_column!], distinct: Boolean): Int!
  max: club_feed_max_fields
  min: club_feed_min_fields
  stddev: club_feed_stddev_fields
  stddev_pop: club_feed_stddev_pop_fields
  stddev_samp: club_feed_stddev_samp_fields
  sum: club_feed_sum_fields
  var_pop: club_feed_var_pop_fields
  var_samp: club_feed_var_samp_fields
  variance: club_feed_variance_fields
}

"""aggregate avg on columns"""
type club_feed_avg_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""
Boolean expression to filter rows from the table "club_feed". All fields are combined with a logical 'AND'.
"""
input club_feed_bool_exp {
  _and: [club_feed_bool_exp!]
  _not: club_feed_bool_exp
  _or: [club_feed_bool_exp!]
  body: String_comparison_exp
  club: clubs_bool_exp
  club_id: uuid_comparison_exp
  comment_count: Int_comparison_exp
  datetime: timestamptz_comparison_exp
  id: uuid_comparison_exp
  image_ids: uuid_array_comparison_exp
  liked_by_user: Boolean_comparison_exp
  likes_count: Int_comparison_exp
  title: String_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
columns and relationships of "club_feed_comments"
"""
type club_feed_comments {
  body: String!

  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int
  datetime: timestamptz!

  """An object relationship"""
  feed: club_feed
  id: uuid!

  """
  A computed field, executes function "comment_liked_by_user"
  """
  liked_by_user: Boolean

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int

  """An object relationship"""
  parent_comment: club_feed_comments
  reaction_id: uuid!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "club_feed_comments"
"""
type club_feed_comments_aggregate {
  aggregate: club_feed_comments_aggregate_fields
  nodes: [club_feed_comments!]!
}

"""
aggregate fields of "club_feed_comments"
"""
type club_feed_comments_aggregate_fields {
  avg: club_feed_comments_avg_fields
  count(columns: [club_feed_comments_select_column!], distinct: Boolean): Int!
  max: club_feed_comments_max_fields
  min: club_feed_comments_min_fields
  stddev: club_feed_comments_stddev_fields
  stddev_pop: club_feed_comments_stddev_pop_fields
  stddev_samp: club_feed_comments_stddev_samp_fields
  sum: club_feed_comments_sum_fields
  var_pop: club_feed_comments_var_pop_fields
  var_samp: club_feed_comments_var_samp_fields
  variance: club_feed_comments_variance_fields
}

"""aggregate avg on columns"""
type club_feed_comments_avg_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""
Boolean expression to filter rows from the table "club_feed_comments". All fields are combined with a logical 'AND'.
"""
input club_feed_comments_bool_exp {
  _and: [club_feed_comments_bool_exp!]
  _not: club_feed_comments_bool_exp
  _or: [club_feed_comments_bool_exp!]
  body: String_comparison_exp
  child_count: Int_comparison_exp
  datetime: timestamptz_comparison_exp
  feed: club_feed_bool_exp
  id: uuid_comparison_exp
  liked_by_user: Boolean_comparison_exp
  likes_count: Int_comparison_exp
  parent_comment: club_feed_comments_bool_exp
  reaction_id: uuid_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "club_feed_comments"
"""
enum club_feed_comments_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  club_feed_comments_pkey
}

"""
input type for inserting data into table "club_feed_comments"
"""
input club_feed_comments_insert_input {
  body: String
  datetime: timestamptz
  feed: club_feed_obj_rel_insert_input
  id: uuid
  parent_comment: club_feed_comments_obj_rel_insert_input
  reaction_id: uuid
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type club_feed_comments_max_fields {
  body: String

  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int
  datetime: timestamptz
  id: uuid

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
  reaction_id: uuid
  user_id: uuid
}

"""aggregate min on columns"""
type club_feed_comments_min_fields {
  body: String

  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int
  datetime: timestamptz
  id: uuid

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
  reaction_id: uuid
  user_id: uuid
}

"""
response of any mutation on the table "club_feed_comments"
"""
type club_feed_comments_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [club_feed_comments!]!
}

"""
input type for inserting object relation for remote table "club_feed_comments"
"""
input club_feed_comments_obj_rel_insert_input {
  data: club_feed_comments_insert_input!

  """upsert condition"""
  on_conflict: club_feed_comments_on_conflict
}

"""
on_conflict condition type for table "club_feed_comments"
"""
input club_feed_comments_on_conflict {
  constraint: club_feed_comments_constraint!
  update_columns: [club_feed_comments_update_column!]! = []
  where: club_feed_comments_bool_exp
}

"""Ordering options when selecting data from "club_feed_comments"."""
input club_feed_comments_order_by {
  body: order_by
  child_count: order_by
  datetime: order_by
  feed: club_feed_order_by
  id: order_by
  liked_by_user: order_by
  likes_count: order_by
  parent_comment: club_feed_comments_order_by
  reaction_id: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: club_feed_comments"""
input club_feed_comments_pk_columns_input {
  id: uuid!
}

"""
select columns of table "club_feed_comments"
"""
enum club_feed_comments_select_column {
  """column name"""
  body

  """column name"""
  datetime

  """column name"""
  id

  """column name"""
  reaction_id

  """column name"""
  user_id
}

"""
input type for updating data in table "club_feed_comments"
"""
input club_feed_comments_set_input {
  body: String
  datetime: timestamptz
  id: uuid
  reaction_id: uuid
  user_id: uuid
}

"""aggregate stddev on columns"""
type club_feed_comments_stddev_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""aggregate stddev_pop on columns"""
type club_feed_comments_stddev_pop_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""aggregate stddev_samp on columns"""
type club_feed_comments_stddev_samp_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""
Streaming cursor of the table "club_feed_comments"
"""
input club_feed_comments_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_feed_comments_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_feed_comments_stream_cursor_value_input {
  body: String
  datetime: timestamptz
  id: uuid
  reaction_id: uuid
  user_id: uuid
}

"""aggregate sum on columns"""
type club_feed_comments_sum_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""
update columns of table "club_feed_comments"
"""
enum club_feed_comments_update_column {
  """column name"""
  body

  """column name"""
  datetime

  """column name"""
  id

  """column name"""
  reaction_id

  """column name"""
  user_id
}

input club_feed_comments_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: club_feed_comments_set_input

  """filter the rows which have to be updated"""
  where: club_feed_comments_bool_exp!
}

"""aggregate var_pop on columns"""
type club_feed_comments_var_pop_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""aggregate var_samp on columns"""
type club_feed_comments_var_samp_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""aggregate variance on columns"""
type club_feed_comments_variance_fields {
  """
  A computed field, executes function "comment_child_count"
  """
  child_count: Int

  """
  A computed field, executes function "comment_likes_count"
  """
  likes_count: Int
}

"""
unique or primary key constraints on table "club_feed"
"""
enum club_feed_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  club_feed_pkey
}

"""
Die View ist fr die files da, damit diese eine Relationship zu einem image id
array haben knnen. Nur fr interne Logik gedacht.
"""
type club_feed_image_mapping {
  """An object relationship"""
  feed: club_feed
  feed_id: uuid
  image_id: uuid
}

"""
aggregated selection of "club_feed_image_mapping"
"""
type club_feed_image_mapping_aggregate {
  aggregate: club_feed_image_mapping_aggregate_fields
  nodes: [club_feed_image_mapping!]!
}

"""
aggregate fields of "club_feed_image_mapping"
"""
type club_feed_image_mapping_aggregate_fields {
  count(columns: [club_feed_image_mapping_select_column!], distinct: Boolean): Int!
  max: club_feed_image_mapping_max_fields
  min: club_feed_image_mapping_min_fields
}

"""
Boolean expression to filter rows from the table "club_feed_image_mapping". All fields are combined with a logical 'AND'.
"""
input club_feed_image_mapping_bool_exp {
  _and: [club_feed_image_mapping_bool_exp!]
  _not: club_feed_image_mapping_bool_exp
  _or: [club_feed_image_mapping_bool_exp!]
  feed: club_feed_bool_exp
  feed_id: uuid_comparison_exp
  image_id: uuid_comparison_exp
}

"""
input type for inserting data into table "club_feed_image_mapping"
"""
input club_feed_image_mapping_insert_input {
  feed: club_feed_obj_rel_insert_input
  feed_id: uuid
  image_id: uuid
}

"""aggregate max on columns"""
type club_feed_image_mapping_max_fields {
  feed_id: uuid
  image_id: uuid
}

"""aggregate min on columns"""
type club_feed_image_mapping_min_fields {
  feed_id: uuid
  image_id: uuid
}

"""
input type for inserting object relation for remote table "club_feed_image_mapping"
"""
input club_feed_image_mapping_obj_rel_insert_input {
  data: club_feed_image_mapping_insert_input!
}

"""Ordering options when selecting data from "club_feed_image_mapping"."""
input club_feed_image_mapping_order_by {
  feed: club_feed_order_by
  feed_id: order_by
  image_id: order_by
}

"""
select columns of table "club_feed_image_mapping"
"""
enum club_feed_image_mapping_select_column {
  """column name"""
  feed_id

  """column name"""
  image_id
}

"""
Streaming cursor of the table "club_feed_image_mapping"
"""
input club_feed_image_mapping_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_feed_image_mapping_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_feed_image_mapping_stream_cursor_value_input {
  feed_id: uuid
  image_id: uuid
}

"""
input type for inserting data into table "club_feed"
"""
input club_feed_insert_input {
  body: String
  club: clubs_obj_rel_insert_input
  club_id: uuid
  datetime: timestamptz
  id: uuid
  image_ids: [uuid!]
  title: String
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""
columns and relationships of "club_feed_likes"
"""
type club_feed_likes {
  """An object relationship"""
  comment: club_feed_comments

  """An object relationship"""
  feed: club_feed
  reaction_id: uuid!
  user_id: uuid!
}

"""
aggregated selection of "club_feed_likes"
"""
type club_feed_likes_aggregate {
  aggregate: club_feed_likes_aggregate_fields
  nodes: [club_feed_likes!]!
}

"""
aggregate fields of "club_feed_likes"
"""
type club_feed_likes_aggregate_fields {
  count(columns: [club_feed_likes_select_column!], distinct: Boolean): Int!
  max: club_feed_likes_max_fields
  min: club_feed_likes_min_fields
}

"""
Boolean expression to filter rows from the table "club_feed_likes". All fields are combined with a logical 'AND'.
"""
input club_feed_likes_bool_exp {
  _and: [club_feed_likes_bool_exp!]
  _not: club_feed_likes_bool_exp
  _or: [club_feed_likes_bool_exp!]
  comment: club_feed_comments_bool_exp
  feed: club_feed_bool_exp
  reaction_id: uuid_comparison_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "club_feed_likes"
"""
enum club_feed_likes_constraint {
  """
  unique or primary key constraint on columns "user_id", "reaction_id"
  """
  club_feed_likes_pkey
}

"""
input type for inserting data into table "club_feed_likes"
"""
input club_feed_likes_insert_input {
  comment: club_feed_comments_obj_rel_insert_input
  feed: club_feed_obj_rel_insert_input
  reaction_id: uuid
  user_id: uuid
}

"""aggregate max on columns"""
type club_feed_likes_max_fields {
  reaction_id: uuid
  user_id: uuid
}

"""aggregate min on columns"""
type club_feed_likes_min_fields {
  reaction_id: uuid
  user_id: uuid
}

"""
response of any mutation on the table "club_feed_likes"
"""
type club_feed_likes_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [club_feed_likes!]!
}

"""
on_conflict condition type for table "club_feed_likes"
"""
input club_feed_likes_on_conflict {
  constraint: club_feed_likes_constraint!
  update_columns: [club_feed_likes_update_column!]! = []
  where: club_feed_likes_bool_exp
}

"""Ordering options when selecting data from "club_feed_likes"."""
input club_feed_likes_order_by {
  comment: club_feed_comments_order_by
  feed: club_feed_order_by
  reaction_id: order_by
  user_id: order_by
}

"""primary key columns input for table: club_feed_likes"""
input club_feed_likes_pk_columns_input {
  reaction_id: uuid!
  user_id: uuid!
}

"""
select columns of table "club_feed_likes"
"""
enum club_feed_likes_select_column {
  """column name"""
  reaction_id

  """column name"""
  user_id
}

"""
input type for updating data in table "club_feed_likes"
"""
input club_feed_likes_set_input {
  reaction_id: uuid
  user_id: uuid
}

"""
Streaming cursor of the table "club_feed_likes"
"""
input club_feed_likes_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_feed_likes_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_feed_likes_stream_cursor_value_input {
  reaction_id: uuid
  user_id: uuid
}

"""
update columns of table "club_feed_likes"
"""
enum club_feed_likes_update_column {
  """column name"""
  reaction_id

  """column name"""
  user_id
}

input club_feed_likes_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: club_feed_likes_set_input

  """filter the rows which have to be updated"""
  where: club_feed_likes_bool_exp!
}

"""aggregate max on columns"""
type club_feed_max_fields {
  body: String
  club_id: uuid

  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int
  datetime: timestamptz
  id: uuid
  image_ids: [uuid!]

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
  title: String
  user_id: uuid
}

"""aggregate min on columns"""
type club_feed_min_fields {
  body: String
  club_id: uuid

  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int
  datetime: timestamptz
  id: uuid
  image_ids: [uuid!]

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
  title: String
  user_id: uuid
}

"""
response of any mutation on the table "club_feed"
"""
type club_feed_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [club_feed!]!
}

"""
input type for inserting object relation for remote table "club_feed"
"""
input club_feed_obj_rel_insert_input {
  data: club_feed_insert_input!

  """upsert condition"""
  on_conflict: club_feed_on_conflict
}

"""
on_conflict condition type for table "club_feed"
"""
input club_feed_on_conflict {
  constraint: club_feed_constraint!
  update_columns: [club_feed_update_column!]! = []
  where: club_feed_bool_exp
}

"""Ordering options when selecting data from "club_feed"."""
input club_feed_order_by {
  body: order_by
  club: clubs_order_by
  club_id: order_by
  comment_count: order_by
  datetime: order_by
  id: order_by
  image_ids: order_by
  liked_by_user: order_by
  likes_count: order_by
  title: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: club_feed"""
input club_feed_pk_columns_input {
  id: uuid!
}

"""
select columns of table "club_feed"
"""
enum club_feed_select_column {
  """column name"""
  body

  """column name"""
  club_id

  """column name"""
  datetime

  """column name"""
  id

  """column name"""
  image_ids

  """column name"""
  title

  """column name"""
  user_id
}

"""
input type for updating data in table "club_feed"
"""
input club_feed_set_input {
  body: String
  club_id: uuid
  datetime: timestamptz
  id: uuid
  image_ids: [uuid!]
  title: String
  user_id: uuid
}

"""aggregate stddev on columns"""
type club_feed_stddev_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""aggregate stddev_pop on columns"""
type club_feed_stddev_pop_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""aggregate stddev_samp on columns"""
type club_feed_stddev_samp_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""
Streaming cursor of the table "club_feed"
"""
input club_feed_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_feed_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_feed_stream_cursor_value_input {
  body: String
  club_id: uuid
  datetime: timestamptz
  id: uuid
  image_ids: [uuid!]
  title: String
  user_id: uuid
}

"""aggregate sum on columns"""
type club_feed_sum_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""
update columns of table "club_feed"
"""
enum club_feed_update_column {
  """column name"""
  body

  """column name"""
  club_id

  """column name"""
  datetime

  """column name"""
  id

  """column name"""
  image_ids

  """column name"""
  title

  """column name"""
  user_id
}

input club_feed_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: club_feed_set_input

  """filter the rows which have to be updated"""
  where: club_feed_bool_exp!
}

"""aggregate var_pop on columns"""
type club_feed_var_pop_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""aggregate var_samp on columns"""
type club_feed_var_samp_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""aggregate variance on columns"""
type club_feed_variance_fields {
  """
  A computed field, executes function "club_feed_comment_count"
  """
  comment_count: Int

  """
  A computed field, executes function "feed_likes_count"
  """
  likes_count: Int
}

"""
Eigene View damit jeder User die Anzahl an Usern in einem Club sehen kann.
Andernfalls ist es permission technisch schiwerig umzusetzen
"""
type club_user_counts {
  club_id: uuid
  user_count: bigint
}

"""
aggregated selection of "club_user_counts"
"""
type club_user_counts_aggregate {
  aggregate: club_user_counts_aggregate_fields
  nodes: [club_user_counts!]!
}

"""
aggregate fields of "club_user_counts"
"""
type club_user_counts_aggregate_fields {
  avg: club_user_counts_avg_fields
  count(columns: [club_user_counts_select_column!], distinct: Boolean): Int!
  max: club_user_counts_max_fields
  min: club_user_counts_min_fields
  stddev: club_user_counts_stddev_fields
  stddev_pop: club_user_counts_stddev_pop_fields
  stddev_samp: club_user_counts_stddev_samp_fields
  sum: club_user_counts_sum_fields
  var_pop: club_user_counts_var_pop_fields
  var_samp: club_user_counts_var_samp_fields
  variance: club_user_counts_variance_fields
}

"""aggregate avg on columns"""
type club_user_counts_avg_fields {
  user_count: Float
}

"""
Boolean expression to filter rows from the table "club_user_counts". All fields are combined with a logical 'AND'.
"""
input club_user_counts_bool_exp {
  _and: [club_user_counts_bool_exp!]
  _not: club_user_counts_bool_exp
  _or: [club_user_counts_bool_exp!]
  club_id: uuid_comparison_exp
  user_count: bigint_comparison_exp
}

"""
input type for inserting data into table "club_user_counts"
"""
input club_user_counts_insert_input {
  club_id: uuid
  user_count: bigint
}

"""aggregate max on columns"""
type club_user_counts_max_fields {
  club_id: uuid
  user_count: bigint
}

"""aggregate min on columns"""
type club_user_counts_min_fields {
  club_id: uuid
  user_count: bigint
}

"""
input type for inserting object relation for remote table "club_user_counts"
"""
input club_user_counts_obj_rel_insert_input {
  data: club_user_counts_insert_input!
}

"""Ordering options when selecting data from "club_user_counts"."""
input club_user_counts_order_by {
  club_id: order_by
  user_count: order_by
}

"""
select columns of table "club_user_counts"
"""
enum club_user_counts_select_column {
  """column name"""
  club_id

  """column name"""
  user_count
}

"""aggregate stddev on columns"""
type club_user_counts_stddev_fields {
  user_count: Float
}

"""aggregate stddev_pop on columns"""
type club_user_counts_stddev_pop_fields {
  user_count: Float
}

"""aggregate stddev_samp on columns"""
type club_user_counts_stddev_samp_fields {
  user_count: Float
}

"""
Streaming cursor of the table "club_user_counts"
"""
input club_user_counts_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_user_counts_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_user_counts_stream_cursor_value_input {
  club_id: uuid
  user_count: bigint
}

"""aggregate sum on columns"""
type club_user_counts_sum_fields {
  user_count: bigint
}

"""aggregate var_pop on columns"""
type club_user_counts_var_pop_fields {
  user_count: Float
}

"""aggregate var_samp on columns"""
type club_user_counts_var_samp_fields {
  user_count: Float
}

"""aggregate variance on columns"""
type club_user_counts_variance_fields {
  user_count: Float
}

"""
columns and relationships of "club_waters"
"""
type club_waters {
  """An object relationship"""
  club: clubs
  club_id: uuid!
  description: String
  draft: Boolean!
  fish_types: [String!]!
  geo_json(
    """JSON select path"""
    path: String
  ): jsonb!
  id: uuid!
  image_id: uuid
  members_only: Boolean!
  name: String!
}

"""
aggregated selection of "club_waters"
"""
type club_waters_aggregate {
  aggregate: club_waters_aggregate_fields
  nodes: [club_waters!]!
}

"""
aggregate fields of "club_waters"
"""
type club_waters_aggregate_fields {
  count(columns: [club_waters_select_column!], distinct: Boolean): Int!
  max: club_waters_max_fields
  min: club_waters_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input club_waters_append_input {
  geo_json: jsonb
}

"""
Boolean expression to filter rows from the table "club_waters". All fields are combined with a logical 'AND'.
"""
input club_waters_bool_exp {
  _and: [club_waters_bool_exp!]
  _not: club_waters_bool_exp
  _or: [club_waters_bool_exp!]
  club: clubs_bool_exp
  club_id: uuid_comparison_exp
  description: String_comparison_exp
  draft: Boolean_comparison_exp
  fish_types: String_array_comparison_exp
  geo_json: jsonb_comparison_exp
  id: uuid_comparison_exp
  image_id: uuid_comparison_exp
  members_only: Boolean_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "club_waters"
"""
enum club_waters_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  club_waters_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input club_waters_delete_at_path_input {
  geo_json: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input club_waters_delete_elem_input {
  geo_json: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input club_waters_delete_key_input {
  geo_json: String
}

"""
input type for inserting data into table "club_waters"
"""
input club_waters_insert_input {
  club: clubs_obj_rel_insert_input
  club_id: uuid
  description: String
  draft: Boolean
  fish_types: [String!]
  geo_json: jsonb
  id: uuid
  image_id: uuid
  members_only: Boolean
  name: String
}

"""aggregate max on columns"""
type club_waters_max_fields {
  club_id: uuid
  description: String
  fish_types: [String!]
  id: uuid
  image_id: uuid
  name: String
}

"""aggregate min on columns"""
type club_waters_min_fields {
  club_id: uuid
  description: String
  fish_types: [String!]
  id: uuid
  image_id: uuid
  name: String
}

"""
response of any mutation on the table "club_waters"
"""
type club_waters_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [club_waters!]!
}

"""
input type for inserting object relation for remote table "club_waters"
"""
input club_waters_obj_rel_insert_input {
  data: club_waters_insert_input!

  """upsert condition"""
  on_conflict: club_waters_on_conflict
}

"""
on_conflict condition type for table "club_waters"
"""
input club_waters_on_conflict {
  constraint: club_waters_constraint!
  update_columns: [club_waters_update_column!]! = []
  where: club_waters_bool_exp
}

"""Ordering options when selecting data from "club_waters"."""
input club_waters_order_by {
  club: clubs_order_by
  club_id: order_by
  description: order_by
  draft: order_by
  fish_types: order_by
  geo_json: order_by
  id: order_by
  image_id: order_by
  members_only: order_by
  name: order_by
}

"""primary key columns input for table: club_waters"""
input club_waters_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input club_waters_prepend_input {
  geo_json: jsonb
}

"""
select columns of table "club_waters"
"""
enum club_waters_select_column {
  """column name"""
  club_id

  """column name"""
  description

  """column name"""
  draft

  """column name"""
  fish_types

  """column name"""
  geo_json

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  members_only

  """column name"""
  name
}

"""
input type for updating data in table "club_waters"
"""
input club_waters_set_input {
  club_id: uuid
  description: String
  draft: Boolean
  fish_types: [String!]
  geo_json: jsonb
  id: uuid
  image_id: uuid
  members_only: Boolean
  name: String
}

"""
Streaming cursor of the table "club_waters"
"""
input club_waters_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: club_waters_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input club_waters_stream_cursor_value_input {
  club_id: uuid
  description: String
  draft: Boolean
  fish_types: [String!]
  geo_json: jsonb
  id: uuid
  image_id: uuid
  members_only: Boolean
  name: String
}

"""
update columns of table "club_waters"
"""
enum club_waters_update_column {
  """column name"""
  club_id

  """column name"""
  description

  """column name"""
  draft

  """column name"""
  fish_types

  """column name"""
  geo_json

  """column name"""
  id

  """column name"""
  image_id

  """column name"""
  members_only

  """column name"""
  name
}

input club_waters_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: club_waters_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: club_waters_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: club_waters_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: club_waters_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: club_waters_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: club_waters_set_input

  """filter the rows which have to be updated"""
  where: club_waters_bool_exp!
}

type ClubFeedClub {
  name: String!
}

type ClubFeedComments {
  body: String!
  child_count: Int!
  datetime: timestamptz!
  id: uuid!
  liked_by_user: Boolean!
  likes_count: Int!
  reaction_id: uuid!
  user: ClubFeedCommentUser!
}

type ClubFeedCommentUser {
  avatarUrl: String!
  displayName: String!
  id: uuid!
}

type ClubFeedOutput {
  body: String!
  club: ClubFeedClub
  comment_count: Int!
  datetime: timestamptz!
  id: uuid!
  image_ids: [String!]!
  liked_by_user: Boolean!
  likes_count: Int!
  title: String!
  user: ClubFeedUser
}

type ClubFeedUser {
  avatarUrl: String!
  displayName: String!
  id: uuid!
  metadata: jsonb
}

"""
columns and relationships of "clubs"
"""
type clubs {
  address: String
  city: String

  """An array relationship"""
  club_documents(
    """distinct select on columns"""
    distinct_on: [club_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_documents_order_by!]

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): [club_documents!]!

  """An aggregate relationship"""
  club_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [club_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_documents_order_by!]

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): club_documents_aggregate!

  """An object relationship"""
  club_user_count_view: club_user_counts
  contact_name: String
  contact_phone_number: String
  country: String
  created_at: timestamptz
  description: String
  id: uuid!
  location: geography
  max_users: Int!
  name: String!
  phone_number: String
  secret: String!

  """An array relationship"""
  user_club_relations(
    """distinct select on columns"""
    distinct_on: [user_club_relation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_club_relation_order_by!]

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): [user_club_relation!]!

  """An aggregate relationship"""
  user_club_relations_aggregate(
    """distinct select on columns"""
    distinct_on: [user_club_relation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_club_relation_order_by!]

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): user_club_relation_aggregate!
  version: bigint!
  website: String
  zip_code: String
}

"""
aggregated selection of "clubs"
"""
type clubs_aggregate {
  aggregate: clubs_aggregate_fields
  nodes: [clubs!]!
}

"""
aggregate fields of "clubs"
"""
type clubs_aggregate_fields {
  avg: clubs_avg_fields
  count(columns: [clubs_select_column!], distinct: Boolean): Int!
  max: clubs_max_fields
  min: clubs_min_fields
  stddev: clubs_stddev_fields
  stddev_pop: clubs_stddev_pop_fields
  stddev_samp: clubs_stddev_samp_fields
  sum: clubs_sum_fields
  var_pop: clubs_var_pop_fields
  var_samp: clubs_var_samp_fields
  variance: clubs_variance_fields
}

"""aggregate avg on columns"""
type clubs_avg_fields {
  max_users: Float
  version: Float
}

"""
Boolean expression to filter rows from the table "clubs". All fields are combined with a logical 'AND'.
"""
input clubs_bool_exp {
  _and: [clubs_bool_exp!]
  _not: clubs_bool_exp
  _or: [clubs_bool_exp!]
  address: String_comparison_exp
  city: String_comparison_exp
  club_documents: club_documents_bool_exp
  club_documents_aggregate: club_documents_aggregate_bool_exp
  club_user_count_view: club_user_counts_bool_exp
  contact_name: String_comparison_exp
  contact_phone_number: String_comparison_exp
  country: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  location: geography_comparison_exp
  max_users: Int_comparison_exp
  name: String_comparison_exp
  phone_number: String_comparison_exp
  secret: String_comparison_exp
  user_club_relations: user_club_relation_bool_exp
  user_club_relations_aggregate: user_club_relation_aggregate_bool_exp
  version: bigint_comparison_exp
  website: String_comparison_exp
  zip_code: String_comparison_exp
}

"""
unique or primary key constraints on table "clubs"
"""
enum clubs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  clubs_pkey
}

"""
input type for incrementing numeric columns in table "clubs"
"""
input clubs_inc_input {
  max_users: Int
  version: bigint
}

"""
input type for inserting data into table "clubs"
"""
input clubs_insert_input {
  address: String
  city: String
  club_documents: club_documents_arr_rel_insert_input
  club_user_count_view: club_user_counts_obj_rel_insert_input
  contact_name: String
  contact_phone_number: String
  country: String
  created_at: timestamptz
  description: String
  id: uuid
  location: geography
  max_users: Int
  name: String
  phone_number: String
  secret: String
  user_club_relations: user_club_relation_arr_rel_insert_input
  version: bigint
  website: String
  zip_code: String
}

"""aggregate max on columns"""
type clubs_max_fields {
  address: String
  city: String
  contact_name: String
  contact_phone_number: String
  country: String
  created_at: timestamptz
  description: String
  id: uuid
  max_users: Int
  name: String
  phone_number: String
  secret: String
  version: bigint
  website: String
  zip_code: String
}

"""aggregate min on columns"""
type clubs_min_fields {
  address: String
  city: String
  contact_name: String
  contact_phone_number: String
  country: String
  created_at: timestamptz
  description: String
  id: uuid
  max_users: Int
  name: String
  phone_number: String
  secret: String
  version: bigint
  website: String
  zip_code: String
}

"""
response of any mutation on the table "clubs"
"""
type clubs_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [clubs!]!
}

input clubs_nearby_args {
  lat: float8
  lon: float8
}

"""
input type for inserting object relation for remote table "clubs"
"""
input clubs_obj_rel_insert_input {
  data: clubs_insert_input!

  """upsert condition"""
  on_conflict: clubs_on_conflict
}

"""
on_conflict condition type for table "clubs"
"""
input clubs_on_conflict {
  constraint: clubs_constraint!
  update_columns: [clubs_update_column!]! = []
  where: clubs_bool_exp
}

"""Ordering options when selecting data from "clubs"."""
input clubs_order_by {
  address: order_by
  city: order_by
  club_documents_aggregate: club_documents_aggregate_order_by
  club_user_count_view: club_user_counts_order_by
  contact_name: order_by
  contact_phone_number: order_by
  country: order_by
  created_at: order_by
  description: order_by
  id: order_by
  location: order_by
  max_users: order_by
  name: order_by
  phone_number: order_by
  secret: order_by
  user_club_relations_aggregate: user_club_relation_aggregate_order_by
  version: order_by
  website: order_by
  zip_code: order_by
}

"""primary key columns input for table: clubs"""
input clubs_pk_columns_input {
  id: uuid!
}

"""
select columns of table "clubs"
"""
enum clubs_select_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  contact_name

  """column name"""
  contact_phone_number

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  location

  """column name"""
  max_users

  """column name"""
  name

  """column name"""
  phone_number

  """column name"""
  secret

  """column name"""
  version

  """column name"""
  website

  """column name"""
  zip_code
}

"""
input type for updating data in table "clubs"
"""
input clubs_set_input {
  address: String
  city: String
  contact_name: String
  contact_phone_number: String
  country: String
  created_at: timestamptz
  description: String
  id: uuid
  location: geography
  max_users: Int
  name: String
  phone_number: String
  secret: String
  version: bigint
  website: String
  zip_code: String
}

"""aggregate stddev on columns"""
type clubs_stddev_fields {
  max_users: Float
  version: Float
}

"""aggregate stddev_pop on columns"""
type clubs_stddev_pop_fields {
  max_users: Float
  version: Float
}

"""aggregate stddev_samp on columns"""
type clubs_stddev_samp_fields {
  max_users: Float
  version: Float
}

"""
Streaming cursor of the table "clubs"
"""
input clubs_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: clubs_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input clubs_stream_cursor_value_input {
  address: String
  city: String
  contact_name: String
  contact_phone_number: String
  country: String
  created_at: timestamptz
  description: String
  id: uuid
  location: geography
  max_users: Int
  name: String
  phone_number: String
  secret: String
  version: bigint
  website: String
  zip_code: String
}

"""aggregate sum on columns"""
type clubs_sum_fields {
  max_users: Int
  version: bigint
}

"""
update columns of table "clubs"
"""
enum clubs_update_column {
  """column name"""
  address

  """column name"""
  city

  """column name"""
  contact_name

  """column name"""
  contact_phone_number

  """column name"""
  country

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  id

  """column name"""
  location

  """column name"""
  max_users

  """column name"""
  name

  """column name"""
  phone_number

  """column name"""
  secret

  """column name"""
  version

  """column name"""
  website

  """column name"""
  zip_code
}

input clubs_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: clubs_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: clubs_set_input

  """filter the rows which have to be updated"""
  where: clubs_bool_exp!
}

"""aggregate var_pop on columns"""
type clubs_var_pop_fields {
  max_users: Float
  version: Float
}

"""aggregate var_samp on columns"""
type clubs_var_samp_fields {
  max_users: Float
  version: Float
}

"""aggregate variance on columns"""
type clubs_variance_fields {
  max_users: Float
  version: Float
}

enum ClubUserOrderByEnum {
  DISPLAY_NAME_ASC
  DISPLAY_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  LAST_SEEN_ASC
  LAST_SEEN_DESC
  ROLE_ASC
  ROLE_DESC
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""
columns and relationships of "documents"
"""
type documents {
  document_status: _enumtable_document_status_enum!
  document_type: _enumtable_document_type_enum!

  """An object relationship"""
  file: files!
  file_id: uuid!
  id: uuid!
  rejected_reason: String

  """An object relationship"""
  user: users!
  user_id: uuid!
  version: bigint!
}

"""
aggregated selection of "documents"
"""
type documents_aggregate {
  aggregate: documents_aggregate_fields
  nodes: [documents!]!
}

input documents_aggregate_bool_exp {
  count: documents_aggregate_bool_exp_count
}

input documents_aggregate_bool_exp_count {
  arguments: [documents_select_column!]
  distinct: Boolean
  filter: documents_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "documents"
"""
type documents_aggregate_fields {
  avg: documents_avg_fields
  count(columns: [documents_select_column!], distinct: Boolean): Int!
  max: documents_max_fields
  min: documents_min_fields
  stddev: documents_stddev_fields
  stddev_pop: documents_stddev_pop_fields
  stddev_samp: documents_stddev_samp_fields
  sum: documents_sum_fields
  var_pop: documents_var_pop_fields
  var_samp: documents_var_samp_fields
  variance: documents_variance_fields
}

"""
order by aggregate values of table "documents"
"""
input documents_aggregate_order_by {
  avg: documents_avg_order_by
  count: order_by
  max: documents_max_order_by
  min: documents_min_order_by
  stddev: documents_stddev_order_by
  stddev_pop: documents_stddev_pop_order_by
  stddev_samp: documents_stddev_samp_order_by
  sum: documents_sum_order_by
  var_pop: documents_var_pop_order_by
  var_samp: documents_var_samp_order_by
  variance: documents_variance_order_by
}

"""
input type for inserting array relation for remote table "documents"
"""
input documents_arr_rel_insert_input {
  data: [documents_insert_input!]!

  """upsert condition"""
  on_conflict: documents_on_conflict
}

"""aggregate avg on columns"""
type documents_avg_fields {
  version: Float
}

"""
order by avg() on columns of table "documents"
"""
input documents_avg_order_by {
  version: order_by
}

"""
Boolean expression to filter rows from the table "documents". All fields are combined with a logical 'AND'.
"""
input documents_bool_exp {
  _and: [documents_bool_exp!]
  _not: documents_bool_exp
  _or: [documents_bool_exp!]
  document_status: _enumtable_document_status_enum_comparison_exp
  document_type: _enumtable_document_type_enum_comparison_exp
  file: files_bool_exp
  file_id: uuid_comparison_exp
  id: uuid_comparison_exp
  rejected_reason: String_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
  version: bigint_comparison_exp
}

"""
unique or primary key constraints on table "documents"
"""
enum documents_constraint {
  """
  unique or primary key constraint on columns "file_id"
  """
  documents_file_id_key

  """
  unique or primary key constraint on columns "id"
  """
  documents_pkey
}

"""
input type for incrementing numeric columns in table "documents"
"""
input documents_inc_input {
  version: bigint
}

"""
input type for inserting data into table "documents"
"""
input documents_insert_input {
  document_status: _enumtable_document_status_enum
  document_type: _enumtable_document_type_enum
  file: files_obj_rel_insert_input
  file_id: uuid
  id: uuid
  rejected_reason: String
  user: users_obj_rel_insert_input
  user_id: uuid
  version: bigint
}

"""aggregate max on columns"""
type documents_max_fields {
  file_id: uuid
  id: uuid
  rejected_reason: String
  user_id: uuid
  version: bigint
}

"""
order by max() on columns of table "documents"
"""
input documents_max_order_by {
  file_id: order_by
  id: order_by
  rejected_reason: order_by
  user_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type documents_min_fields {
  file_id: uuid
  id: uuid
  rejected_reason: String
  user_id: uuid
  version: bigint
}

"""
order by min() on columns of table "documents"
"""
input documents_min_order_by {
  file_id: order_by
  id: order_by
  rejected_reason: order_by
  user_id: order_by
  version: order_by
}

"""
response of any mutation on the table "documents"
"""
type documents_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [documents!]!
}

"""
input type for inserting object relation for remote table "documents"
"""
input documents_obj_rel_insert_input {
  data: documents_insert_input!

  """upsert condition"""
  on_conflict: documents_on_conflict
}

"""
on_conflict condition type for table "documents"
"""
input documents_on_conflict {
  constraint: documents_constraint!
  update_columns: [documents_update_column!]! = []
  where: documents_bool_exp
}

"""Ordering options when selecting data from "documents"."""
input documents_order_by {
  document_status: order_by
  document_type: order_by
  file: files_order_by
  file_id: order_by
  id: order_by
  rejected_reason: order_by
  user: users_order_by
  user_id: order_by
  version: order_by
}

"""primary key columns input for table: documents"""
input documents_pk_columns_input {
  id: uuid!
}

"""
select columns of table "documents"
"""
enum documents_select_column {
  """column name"""
  document_status

  """column name"""
  document_type

  """column name"""
  file_id

  """column name"""
  id

  """column name"""
  rejected_reason

  """column name"""
  user_id

  """column name"""
  version
}

"""
input type for updating data in table "documents"
"""
input documents_set_input {
  document_status: _enumtable_document_status_enum
  document_type: _enumtable_document_type_enum
  file_id: uuid
  id: uuid
  rejected_reason: String
  user_id: uuid
  version: bigint
}

"""aggregate stddev on columns"""
type documents_stddev_fields {
  version: Float
}

"""
order by stddev() on columns of table "documents"
"""
input documents_stddev_order_by {
  version: order_by
}

"""aggregate stddev_pop on columns"""
type documents_stddev_pop_fields {
  version: Float
}

"""
order by stddev_pop() on columns of table "documents"
"""
input documents_stddev_pop_order_by {
  version: order_by
}

"""aggregate stddev_samp on columns"""
type documents_stddev_samp_fields {
  version: Float
}

"""
order by stddev_samp() on columns of table "documents"
"""
input documents_stddev_samp_order_by {
  version: order_by
}

"""
Streaming cursor of the table "documents"
"""
input documents_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: documents_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input documents_stream_cursor_value_input {
  document_status: _enumtable_document_status_enum
  document_type: _enumtable_document_type_enum
  file_id: uuid
  id: uuid
  rejected_reason: String
  user_id: uuid
  version: bigint
}

"""aggregate sum on columns"""
type documents_sum_fields {
  version: bigint
}

"""
order by sum() on columns of table "documents"
"""
input documents_sum_order_by {
  version: order_by
}

"""
update columns of table "documents"
"""
enum documents_update_column {
  """column name"""
  document_status

  """column name"""
  document_type

  """column name"""
  file_id

  """column name"""
  id

  """column name"""
  rejected_reason

  """column name"""
  user_id

  """column name"""
  version
}

input documents_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: documents_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: documents_set_input

  """filter the rows which have to be updated"""
  where: documents_bool_exp!
}

"""aggregate var_pop on columns"""
type documents_var_pop_fields {
  version: Float
}

"""
order by var_pop() on columns of table "documents"
"""
input documents_var_pop_order_by {
  version: order_by
}

"""aggregate var_samp on columns"""
type documents_var_samp_fields {
  version: Float
}

"""
order by var_samp() on columns of table "documents"
"""
input documents_var_samp_order_by {
  version: order_by
}

"""aggregate variance on columns"""
type documents_variance_fields {
  version: Float
}

"""
order by variance() on columns of table "documents"
"""
input documents_variance_order_by {
  version: order_by
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!

  """An object relationship"""
  club_document: club_documents

  """An object relationship"""
  club_water: club_waters
  createdAt: timestamptz!

  """An object relationship"""
  documents: documents
  etag: String

  """An object relationship"""
  feed_image: club_feed_image_mapping
  id: uuid!
  isUploaded: Boolean
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

input files_aggregate_bool_exp {
  bool_and: files_aggregate_bool_exp_bool_and
  bool_or: files_aggregate_bool_exp_bool_or
  count: files_aggregate_bool_exp_count
}

input files_aggregate_bool_exp_bool_and {
  arguments: files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_bool_or {
  arguments: files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: files_bool_exp
  predicate: Boolean_comparison_exp!
}

input files_aggregate_bool_exp_count {
  arguments: [files_select_column!]
  distinct: Boolean
  filter: files_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input files_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  club_document: club_documents_bool_exp
  club_water: club_waters_bool_exp
  createdAt: timestamptz_comparison_exp
  documents: documents_bool_exp
  etag: String_comparison_exp
  feed_image: club_feed_image_mapping_bool_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  metadata: jsonb_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  files_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input files_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input files_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input files_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  club_document: club_documents_obj_rel_insert_input
  club_water: club_waters_obj_rel_insert_input
  createdAt: timestamptz
  documents: documents_obj_rel_insert_input
  etag: String
  feed_image: club_feed_image_mapping_obj_rel_insert_input
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
input type for inserting object relation for remote table "storage.files"
"""
input files_obj_rel_insert_input {
  data: files_insert_input!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  club_document: club_documents_order_by
  club_water: club_waters_order_by
  createdAt: order_by
  documents: documents_order_by
  etag: order_by
  feed_image: club_feed_image_mapping_order_by
  id: order_by
  isUploaded: order_by
  metadata: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: storage.files"""
input files_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input files_prepend_input {
  metadata: jsonb
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
select "files_aggregate_bool_exp_bool_and_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  isUploaded
}

"""
select "files_aggregate_bool_exp_bool_or_arguments_columns" columns of table "storage.files"
"""
enum files_select_column_files_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  isUploaded
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""
Streaming cursor of the table "files"
"""
input files_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: files_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input files_stream_cursor_value_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  metadata: jsonb
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  metadata

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

input files_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: files_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: files_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: files_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: files_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: files_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: files_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: files_set_input

  """filter the rows which have to be updated"""
  where: files_bool_exp!
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

"""
columns and relationships of "fishing_days"
"""
type fishing_days {
  """An array relationship"""
  catches(
    """distinct select on columns"""
    distinct_on: [catches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [catches_order_by!]

    """filter the rows returned"""
    where: catches_bool_exp
  ): [catches!]!

  """An aggregate relationship"""
  catches_aggregate(
    """distinct select on columns"""
    distinct_on: [catches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [catches_order_by!]

    """filter the rows returned"""
    where: catches_bool_exp
  ): catches_aggregate!
  end_date: timestamptz
  id: uuid!
  start_date: timestamptz!
  user_id: uuid!

  """An object relationship"""
  water: club_waters
  water_id: uuid!
}

"""
aggregated selection of "fishing_days"
"""
type fishing_days_aggregate {
  aggregate: fishing_days_aggregate_fields
  nodes: [fishing_days!]!
}

"""
aggregate fields of "fishing_days"
"""
type fishing_days_aggregate_fields {
  count(columns: [fishing_days_select_column!], distinct: Boolean): Int!
  max: fishing_days_max_fields
  min: fishing_days_min_fields
}

"""
Boolean expression to filter rows from the table "fishing_days". All fields are combined with a logical 'AND'.
"""
input fishing_days_bool_exp {
  _and: [fishing_days_bool_exp!]
  _not: fishing_days_bool_exp
  _or: [fishing_days_bool_exp!]
  catches: catches_bool_exp
  catches_aggregate: catches_aggregate_bool_exp
  end_date: timestamptz_comparison_exp
  id: uuid_comparison_exp
  start_date: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
  water: club_waters_bool_exp
  water_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "fishing_days"
"""
enum fishing_days_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  fishing_days_pkey
}

"""
input type for inserting data into table "fishing_days"
"""
input fishing_days_insert_input {
  catches: catches_arr_rel_insert_input
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  user_id: uuid
  water: club_waters_obj_rel_insert_input
  water_id: uuid
}

"""aggregate max on columns"""
type fishing_days_max_fields {
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  user_id: uuid
  water_id: uuid
}

"""aggregate min on columns"""
type fishing_days_min_fields {
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  user_id: uuid
  water_id: uuid
}

"""
response of any mutation on the table "fishing_days"
"""
type fishing_days_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [fishing_days!]!
}

"""
input type for inserting object relation for remote table "fishing_days"
"""
input fishing_days_obj_rel_insert_input {
  data: fishing_days_insert_input!

  """upsert condition"""
  on_conflict: fishing_days_on_conflict
}

"""
on_conflict condition type for table "fishing_days"
"""
input fishing_days_on_conflict {
  constraint: fishing_days_constraint!
  update_columns: [fishing_days_update_column!]! = []
  where: fishing_days_bool_exp
}

"""Ordering options when selecting data from "fishing_days"."""
input fishing_days_order_by {
  catches_aggregate: catches_aggregate_order_by
  end_date: order_by
  id: order_by
  start_date: order_by
  user_id: order_by
  water: club_waters_order_by
  water_id: order_by
}

"""primary key columns input for table: fishing_days"""
input fishing_days_pk_columns_input {
  id: uuid!
}

"""
select columns of table "fishing_days"
"""
enum fishing_days_select_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  start_date

  """column name"""
  user_id

  """column name"""
  water_id
}

"""
input type for updating data in table "fishing_days"
"""
input fishing_days_set_input {
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  user_id: uuid
  water_id: uuid
}

"""
Streaming cursor of the table "fishing_days"
"""
input fishing_days_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: fishing_days_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input fishing_days_stream_cursor_value_input {
  end_date: timestamptz
  id: uuid
  start_date: timestamptz
  user_id: uuid
  water_id: uuid
}

"""
update columns of table "fishing_days"
"""
enum fishing_days_update_column {
  """column name"""
  end_date

  """column name"""
  id

  """column name"""
  start_date

  """column name"""
  user_id

  """column name"""
  water_id
}

input fishing_days_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: fishing_days_set_input

  """filter the rows which have to be updated"""
  where: fishing_days_bool_exp!
}

scalar float8

scalar geography

input geography_cast_exp {
  geometry: geometry_comparison_exp
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input geography_comparison_exp {
  _cast: geography_cast_exp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _is_null: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _st_d_within: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _st_intersects: geography
}

scalar geometry

input geometry_cast_exp {
  geography: geography_comparison_exp
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input geometry_comparison_exp {
  _cast: geometry_cast_exp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _is_null: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st_3d_d_within: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st_3d_intersects: geometry

  """does the column contain the given geometry value"""
  _st_contains: geometry

  """does the column cross the given geometry value"""
  _st_crosses: geometry

  """is the column within a given distance from the given geometry value"""
  _st_d_within: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _st_equals: geometry

  """does the column spatially intersect the given geometry value"""
  _st_intersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _st_overlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _st_touches: geometry

  """is the column contained in the given geometry value"""
  _st_within: geometry
}

type GetClubMembersOutput {
  user_club_relation: [UserClubRelation!]!
  user_club_relation_aggregate: UserClubRelationAggregate!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(id: uuid!): authRefreshTokens

  """
  delete single row from the table: "auth.refresh_token_types"
  """
  deleteAuthRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  delete data from the table: "auth.refresh_token_types"
  """
  deleteAuthRefreshTokenTypes(
    """filter the rows which have to be deleted"""
    where: authRefreshTokenTypes_bool_exp!
  ): authRefreshTokenTypes_mutation_response

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  delete data from the table: "auth.user_security_keys"
  """
  deleteAuthUserSecurityKeys(
    """filter the rows which have to be deleted"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "storage.virus"
  """
  deleteVirus(id: uuid!): virus

  """
  delete data from the table: "storage.virus"
  """
  deleteViruses(
    """filter the rows which have to be deleted"""
    where: virus_bool_exp!
  ): virus_mutation_response

  """
  delete data from the table: "_enumtable.document_status"
  """
  delete__enumtable_document_status(
    """filter the rows which have to be deleted"""
    where: _enumtable_document_status_bool_exp!
  ): _enumtable_document_status_mutation_response

  """
  delete single row from the table: "_enumtable.document_status"
  """
  delete__enumtable_document_status_by_pk(value: String!): _enumtable_document_status

  """
  delete data from the table: "_enumtable.document_type"
  """
  delete__enumtable_document_type(
    """filter the rows which have to be deleted"""
    where: _enumtable_document_type_bool_exp!
  ): _enumtable_document_type_mutation_response

  """
  delete single row from the table: "_enumtable.document_type"
  """
  delete__enumtable_document_type_by_pk(value: String!): _enumtable_document_type

  """
  delete data from the table: "_enumtable.fish_type"
  """
  delete__enumtable_fish_type(
    """filter the rows which have to be deleted"""
    where: _enumtable_fish_type_bool_exp!
  ): _enumtable_fish_type_mutation_response

  """
  delete single row from the table: "_enumtable.fish_type"
  """
  delete__enumtable_fish_type_by_pk(type: String!): _enumtable_fish_type

  """
  delete data from the table: "_enumtable.report_reason"
  """
  delete__enumtable_report_reason(
    """filter the rows which have to be deleted"""
    where: _enumtable_report_reason_bool_exp!
  ): _enumtable_report_reason_mutation_response

  """
  delete single row from the table: "_enumtable.report_reason"
  """
  delete__enumtable_report_reason_by_pk(reason: String!): _enumtable_report_reason

  """
  delete data from the table: "_enumtable.user_club_role"
  """
  delete__enumtable_user_club_role(
    """filter the rows which have to be deleted"""
    where: _enumtable_user_club_role_bool_exp!
  ): _enumtable_user_club_role_mutation_response

  """
  delete single row from the table: "_enumtable.user_club_role"
  """
  delete__enumtable_user_club_role_by_pk(role: String!): _enumtable_user_club_role

  """
  delete data from the table: "catches"
  """
  delete_catches(
    """filter the rows which have to be deleted"""
    where: catches_bool_exp!
  ): catches_mutation_response

  """
  delete single row from the table: "catches"
  """
  delete_catches_by_pk(id: uuid!): catches

  """
  delete data from the table: "club_documents"
  """
  delete_club_documents(
    """filter the rows which have to be deleted"""
    where: club_documents_bool_exp!
  ): club_documents_mutation_response

  """
  delete single row from the table: "club_documents"
  """
  delete_club_documents_by_pk(id: uuid!): club_documents

  """
  delete data from the table: "club_feed"
  """
  delete_club_feed(
    """filter the rows which have to be deleted"""
    where: club_feed_bool_exp!
  ): club_feed_mutation_response

  """
  delete single row from the table: "club_feed"
  """
  delete_club_feed_by_pk(id: uuid!): club_feed

  """
  delete data from the table: "club_feed_comments"
  """
  delete_club_feed_comments(
    """filter the rows which have to be deleted"""
    where: club_feed_comments_bool_exp!
  ): club_feed_comments_mutation_response

  """
  delete single row from the table: "club_feed_comments"
  """
  delete_club_feed_comments_by_pk(id: uuid!): club_feed_comments

  """
  delete data from the table: "club_feed_likes"
  """
  delete_club_feed_likes(
    """filter the rows which have to be deleted"""
    where: club_feed_likes_bool_exp!
  ): club_feed_likes_mutation_response

  """
  delete single row from the table: "club_feed_likes"
  """
  delete_club_feed_likes_by_pk(reaction_id: uuid!, user_id: uuid!): club_feed_likes

  """
  delete data from the table: "club_waters"
  """
  delete_club_waters(
    """filter the rows which have to be deleted"""
    where: club_waters_bool_exp!
  ): club_waters_mutation_response

  """
  delete single row from the table: "club_waters"
  """
  delete_club_waters_by_pk(id: uuid!): club_waters

  """
  delete data from the table: "clubs"
  """
  delete_clubs(
    """filter the rows which have to be deleted"""
    where: clubs_bool_exp!
  ): clubs_mutation_response

  """
  delete single row from the table: "clubs"
  """
  delete_clubs_by_pk(id: uuid!): clubs

  """
  delete data from the table: "documents"
  """
  delete_documents(
    """filter the rows which have to be deleted"""
    where: documents_bool_exp!
  ): documents_mutation_response

  """
  delete single row from the table: "documents"
  """
  delete_documents_by_pk(id: uuid!): documents

  """
  delete data from the table: "fishing_days"
  """
  delete_fishing_days(
    """filter the rows which have to be deleted"""
    where: fishing_days_bool_exp!
  ): fishing_days_mutation_response

  """
  delete single row from the table: "fishing_days"
  """
  delete_fishing_days_by_pk(id: uuid!): fishing_days

  """
  delete data from the table: "reports"
  """
  delete_reports(
    """filter the rows which have to be deleted"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  delete single row from the table: "reports"
  """
  delete_reports_by_pk(id: uuid!): reports

  """
  delete data from the table: "user_club_relation"
  """
  delete_user_club_relation(
    """filter the rows which have to be deleted"""
    where: user_club_relation_bool_exp!
  ): user_club_relation_mutation_response

  """
  delete single row from the table: "user_club_relation"
  """
  delete_user_club_relation_by_pk(id: uuid!): user_club_relation

  """
  delete data from the table: "user_created_at"
  """
  delete_user_created_at(
    """filter the rows which have to be deleted"""
    where: user_created_at_bool_exp!
  ): user_created_at_mutation_response

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert a single row into the table: "auth.refresh_token_types"
  """
  insertAuthRefreshTokenType(
    """the row to be inserted"""
    object: authRefreshTokenTypes_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokenTypes_on_conflict
  ): authRefreshTokenTypes

  """
  insert data into the table: "auth.refresh_token_types"
  """
  insertAuthRefreshTokenTypes(
    """the rows to be inserted"""
    objects: [authRefreshTokenTypes_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokenTypes_on_conflict
  ): authRefreshTokenTypes_mutation_response

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKey(
    """the row to be inserted"""
    object: authUserSecurityKeys_insert_input!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys

  """
  insert data into the table: "auth.user_security_keys"
  """
  insertAuthUserSecurityKeys(
    """the rows to be inserted"""
    objects: [authUserSecurityKeys_insert_input!]!

    """upsert condition"""
    on_conflict: authUserSecurityKeys_on_conflict
  ): authUserSecurityKeys_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "storage.virus"
  """
  insertVirus(
    """the row to be inserted"""
    object: virus_insert_input!

    """upsert condition"""
    on_conflict: virus_on_conflict
  ): virus

  """
  insert data into the table: "storage.virus"
  """
  insertViruses(
    """the rows to be inserted"""
    objects: [virus_insert_input!]!

    """upsert condition"""
    on_conflict: virus_on_conflict
  ): virus_mutation_response

  """
  insert data into the table: "_enumtable.document_status"
  """
  insert__enumtable_document_status(
    """the rows to be inserted"""
    objects: [_enumtable_document_status_insert_input!]!

    """upsert condition"""
    on_conflict: _enumtable_document_status_on_conflict
  ): _enumtable_document_status_mutation_response

  """
  insert a single row into the table: "_enumtable.document_status"
  """
  insert__enumtable_document_status_one(
    """the row to be inserted"""
    object: _enumtable_document_status_insert_input!

    """upsert condition"""
    on_conflict: _enumtable_document_status_on_conflict
  ): _enumtable_document_status

  """
  insert data into the table: "_enumtable.document_type"
  """
  insert__enumtable_document_type(
    """the rows to be inserted"""
    objects: [_enumtable_document_type_insert_input!]!

    """upsert condition"""
    on_conflict: _enumtable_document_type_on_conflict
  ): _enumtable_document_type_mutation_response

  """
  insert a single row into the table: "_enumtable.document_type"
  """
  insert__enumtable_document_type_one(
    """the row to be inserted"""
    object: _enumtable_document_type_insert_input!

    """upsert condition"""
    on_conflict: _enumtable_document_type_on_conflict
  ): _enumtable_document_type

  """
  insert data into the table: "_enumtable.fish_type"
  """
  insert__enumtable_fish_type(
    """the rows to be inserted"""
    objects: [_enumtable_fish_type_insert_input!]!

    """upsert condition"""
    on_conflict: _enumtable_fish_type_on_conflict
  ): _enumtable_fish_type_mutation_response

  """
  insert a single row into the table: "_enumtable.fish_type"
  """
  insert__enumtable_fish_type_one(
    """the row to be inserted"""
    object: _enumtable_fish_type_insert_input!

    """upsert condition"""
    on_conflict: _enumtable_fish_type_on_conflict
  ): _enumtable_fish_type

  """
  insert data into the table: "_enumtable.report_reason"
  """
  insert__enumtable_report_reason(
    """the rows to be inserted"""
    objects: [_enumtable_report_reason_insert_input!]!

    """upsert condition"""
    on_conflict: _enumtable_report_reason_on_conflict
  ): _enumtable_report_reason_mutation_response

  """
  insert a single row into the table: "_enumtable.report_reason"
  """
  insert__enumtable_report_reason_one(
    """the row to be inserted"""
    object: _enumtable_report_reason_insert_input!

    """upsert condition"""
    on_conflict: _enumtable_report_reason_on_conflict
  ): _enumtable_report_reason

  """
  insert data into the table: "_enumtable.user_club_role"
  """
  insert__enumtable_user_club_role(
    """the rows to be inserted"""
    objects: [_enumtable_user_club_role_insert_input!]!

    """upsert condition"""
    on_conflict: _enumtable_user_club_role_on_conflict
  ): _enumtable_user_club_role_mutation_response

  """
  insert a single row into the table: "_enumtable.user_club_role"
  """
  insert__enumtable_user_club_role_one(
    """the row to be inserted"""
    object: _enumtable_user_club_role_insert_input!

    """upsert condition"""
    on_conflict: _enumtable_user_club_role_on_conflict
  ): _enumtable_user_club_role

  """
  insert data into the table: "catches"
  """
  insert_catches(
    """the rows to be inserted"""
    objects: [catches_insert_input!]!

    """upsert condition"""
    on_conflict: catches_on_conflict
  ): catches_mutation_response

  """
  insert a single row into the table: "catches"
  """
  insert_catches_one(
    """the row to be inserted"""
    object: catches_insert_input!

    """upsert condition"""
    on_conflict: catches_on_conflict
  ): catches

  """
  insert data into the table: "club_documents"
  """
  insert_club_documents(
    """the rows to be inserted"""
    objects: [club_documents_insert_input!]!

    """upsert condition"""
    on_conflict: club_documents_on_conflict
  ): club_documents_mutation_response

  """
  insert a single row into the table: "club_documents"
  """
  insert_club_documents_one(
    """the row to be inserted"""
    object: club_documents_insert_input!

    """upsert condition"""
    on_conflict: club_documents_on_conflict
  ): club_documents

  """
  insert data into the table: "club_feed"
  """
  insert_club_feed(
    """the rows to be inserted"""
    objects: [club_feed_insert_input!]!

    """upsert condition"""
    on_conflict: club_feed_on_conflict
  ): club_feed_mutation_response

  """
  insert data into the table: "club_feed_comments"
  """
  insert_club_feed_comments(
    """the rows to be inserted"""
    objects: [club_feed_comments_insert_input!]!

    """upsert condition"""
    on_conflict: club_feed_comments_on_conflict
  ): club_feed_comments_mutation_response

  """
  insert a single row into the table: "club_feed_comments"
  """
  insert_club_feed_comments_one(
    """the row to be inserted"""
    object: club_feed_comments_insert_input!

    """upsert condition"""
    on_conflict: club_feed_comments_on_conflict
  ): club_feed_comments

  """
  insert data into the table: "club_feed_likes"
  """
  insert_club_feed_likes(
    """the rows to be inserted"""
    objects: [club_feed_likes_insert_input!]!

    """upsert condition"""
    on_conflict: club_feed_likes_on_conflict
  ): club_feed_likes_mutation_response

  """
  insert a single row into the table: "club_feed_likes"
  """
  insert_club_feed_likes_one(
    """the row to be inserted"""
    object: club_feed_likes_insert_input!

    """upsert condition"""
    on_conflict: club_feed_likes_on_conflict
  ): club_feed_likes

  """
  insert a single row into the table: "club_feed"
  """
  insert_club_feed_one(
    """the row to be inserted"""
    object: club_feed_insert_input!

    """upsert condition"""
    on_conflict: club_feed_on_conflict
  ): club_feed

  """
  insert data into the table: "club_waters"
  """
  insert_club_waters(
    """the rows to be inserted"""
    objects: [club_waters_insert_input!]!

    """upsert condition"""
    on_conflict: club_waters_on_conflict
  ): club_waters_mutation_response

  """
  insert a single row into the table: "club_waters"
  """
  insert_club_waters_one(
    """the row to be inserted"""
    object: club_waters_insert_input!

    """upsert condition"""
    on_conflict: club_waters_on_conflict
  ): club_waters

  """
  insert data into the table: "clubs"
  """
  insert_clubs(
    """the rows to be inserted"""
    objects: [clubs_insert_input!]!

    """upsert condition"""
    on_conflict: clubs_on_conflict
  ): clubs_mutation_response

  """
  insert a single row into the table: "clubs"
  """
  insert_clubs_one(
    """the row to be inserted"""
    object: clubs_insert_input!

    """upsert condition"""
    on_conflict: clubs_on_conflict
  ): clubs

  """
  insert data into the table: "documents"
  """
  insert_documents(
    """the rows to be inserted"""
    objects: [documents_insert_input!]!

    """upsert condition"""
    on_conflict: documents_on_conflict
  ): documents_mutation_response

  """
  insert a single row into the table: "documents"
  """
  insert_documents_one(
    """the row to be inserted"""
    object: documents_insert_input!

    """upsert condition"""
    on_conflict: documents_on_conflict
  ): documents

  """
  insert data into the table: "fishing_days"
  """
  insert_fishing_days(
    """the rows to be inserted"""
    objects: [fishing_days_insert_input!]!

    """upsert condition"""
    on_conflict: fishing_days_on_conflict
  ): fishing_days_mutation_response

  """
  insert a single row into the table: "fishing_days"
  """
  insert_fishing_days_one(
    """the row to be inserted"""
    object: fishing_days_insert_input!

    """upsert condition"""
    on_conflict: fishing_days_on_conflict
  ): fishing_days

  """
  insert data into the table: "reports"
  """
  insert_reports(
    """the rows to be inserted"""
    objects: [reports_insert_input!]!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports_mutation_response

  """
  insert a single row into the table: "reports"
  """
  insert_reports_one(
    """the row to be inserted"""
    object: reports_insert_input!

    """upsert condition"""
    on_conflict: reports_on_conflict
  ): reports

  """
  insert data into the table: "user_club_relation"
  """
  insert_user_club_relation(
    """the rows to be inserted"""
    objects: [user_club_relation_insert_input!]!

    """upsert condition"""
    on_conflict: user_club_relation_on_conflict
  ): user_club_relation_mutation_response

  """
  insert a single row into the table: "user_club_relation"
  """
  insert_user_club_relation_one(
    """the row to be inserted"""
    object: user_club_relation_insert_input!

    """upsert condition"""
    on_conflict: user_club_relation_on_conflict
  ): user_club_relation

  """
  insert data into the table: "user_created_at"
  """
  insert_user_created_at(
    """the rows to be inserted"""
    objects: [user_created_at_insert_input!]!
  ): user_created_at_mutation_response

  """
  insert a single row into the table: "user_created_at"
  """
  insert_user_created_at_one(
    """the row to be inserted"""
    object: user_created_at_insert_input!
  ): user_created_at

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authProviderRequests_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authProviderRequests_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: authProviderRequests_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authProviderRequests_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authProviderRequests_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authRefreshTokens_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authRefreshTokens_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: authRefreshTokens_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authRefreshTokens_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authRefreshTokens_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update single row of the table: "auth.refresh_token_types"
  """
  updateAuthRefreshTokenType(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokenTypes_set_input
    pk_columns: authRefreshTokenTypes_pk_columns_input!
  ): authRefreshTokenTypes

  """
  update data of the table: "auth.refresh_token_types"
  """
  updateAuthRefreshTokenTypes(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokenTypes_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokenTypes_bool_exp!
  ): authRefreshTokenTypes_mutation_response

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: authRefreshTokens_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: authRefreshTokens_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: authRefreshTokens_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: authRefreshTokens_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: authRefreshTokens_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKey(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input
    pk_columns: authUserSecurityKeys_pk_columns_input!
  ): authUserSecurityKeys

  """
  update data of the table: "auth.user_security_keys"
  """
  updateAuthUserSecurityKeys(
    """increments the numeric columns with given value of the filtered values"""
    _inc: authUserSecurityKeys_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: authUserSecurityKeys_set_input

    """filter the rows which have to be updated"""
    where: authUserSecurityKeys_bool_exp!
  ): authUserSecurityKeys_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: files_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: files_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: files_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: files_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: files_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: files_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: files_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: files_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: files_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: files_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "storage.virus"
  """
  updateVirus(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: virus_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: virus_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: virus_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: virus_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: virus_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: virus_set_input
    pk_columns: virus_pk_columns_input!
  ): virus

  """
  update data of the table: "storage.virus"
  """
  updateViruses(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: virus_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: virus_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: virus_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: virus_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: virus_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: virus_set_input

    """filter the rows which have to be updated"""
    where: virus_bool_exp!
  ): virus_mutation_response

  """
  update data of the table: "_enumtable.document_status"
  """
  update__enumtable_document_status(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_document_status_set_input

    """filter the rows which have to be updated"""
    where: _enumtable_document_status_bool_exp!
  ): _enumtable_document_status_mutation_response

  """
  update single row of the table: "_enumtable.document_status"
  """
  update__enumtable_document_status_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_document_status_set_input
    pk_columns: _enumtable_document_status_pk_columns_input!
  ): _enumtable_document_status

  """
  update multiples rows of table: "_enumtable.document_status"
  """
  update__enumtable_document_status_many(
    """updates to execute, in order"""
    updates: [_enumtable_document_status_updates!]!
  ): [_enumtable_document_status_mutation_response]

  """
  update data of the table: "_enumtable.document_type"
  """
  update__enumtable_document_type(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_document_type_set_input

    """filter the rows which have to be updated"""
    where: _enumtable_document_type_bool_exp!
  ): _enumtable_document_type_mutation_response

  """
  update single row of the table: "_enumtable.document_type"
  """
  update__enumtable_document_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_document_type_set_input
    pk_columns: _enumtable_document_type_pk_columns_input!
  ): _enumtable_document_type

  """
  update multiples rows of table: "_enumtable.document_type"
  """
  update__enumtable_document_type_many(
    """updates to execute, in order"""
    updates: [_enumtable_document_type_updates!]!
  ): [_enumtable_document_type_mutation_response]

  """
  update data of the table: "_enumtable.fish_type"
  """
  update__enumtable_fish_type(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_fish_type_set_input

    """filter the rows which have to be updated"""
    where: _enumtable_fish_type_bool_exp!
  ): _enumtable_fish_type_mutation_response

  """
  update single row of the table: "_enumtable.fish_type"
  """
  update__enumtable_fish_type_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_fish_type_set_input
    pk_columns: _enumtable_fish_type_pk_columns_input!
  ): _enumtable_fish_type

  """
  update multiples rows of table: "_enumtable.fish_type"
  """
  update__enumtable_fish_type_many(
    """updates to execute, in order"""
    updates: [_enumtable_fish_type_updates!]!
  ): [_enumtable_fish_type_mutation_response]

  """
  update data of the table: "_enumtable.report_reason"
  """
  update__enumtable_report_reason(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_report_reason_set_input

    """filter the rows which have to be updated"""
    where: _enumtable_report_reason_bool_exp!
  ): _enumtable_report_reason_mutation_response

  """
  update single row of the table: "_enumtable.report_reason"
  """
  update__enumtable_report_reason_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_report_reason_set_input
    pk_columns: _enumtable_report_reason_pk_columns_input!
  ): _enumtable_report_reason

  """
  update multiples rows of table: "_enumtable.report_reason"
  """
  update__enumtable_report_reason_many(
    """updates to execute, in order"""
    updates: [_enumtable_report_reason_updates!]!
  ): [_enumtable_report_reason_mutation_response]

  """
  update data of the table: "_enumtable.user_club_role"
  """
  update__enumtable_user_club_role(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_user_club_role_set_input

    """filter the rows which have to be updated"""
    where: _enumtable_user_club_role_bool_exp!
  ): _enumtable_user_club_role_mutation_response

  """
  update single row of the table: "_enumtable.user_club_role"
  """
  update__enumtable_user_club_role_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: _enumtable_user_club_role_set_input
    pk_columns: _enumtable_user_club_role_pk_columns_input!
  ): _enumtable_user_club_role

  """
  update multiples rows of table: "_enumtable.user_club_role"
  """
  update__enumtable_user_club_role_many(
    """updates to execute, in order"""
    updates: [_enumtable_user_club_role_updates!]!
  ): [_enumtable_user_club_role_mutation_response]

  """
  update multiples rows of table: "auth.provider_requests"
  """
  update_authProviderRequests_many(
    """updates to execute, in order"""
    updates: [authProviderRequests_updates!]!
  ): [authProviderRequests_mutation_response]

  """
  update multiples rows of table: "auth.providers"
  """
  update_authProviders_many(
    """updates to execute, in order"""
    updates: [authProviders_updates!]!
  ): [authProviders_mutation_response]

  """
  update multiples rows of table: "auth.refresh_token_types"
  """
  update_authRefreshTokenTypes_many(
    """updates to execute, in order"""
    updates: [authRefreshTokenTypes_updates!]!
  ): [authRefreshTokenTypes_mutation_response]

  """
  update multiples rows of table: "auth.refresh_tokens"
  """
  update_authRefreshTokens_many(
    """updates to execute, in order"""
    updates: [authRefreshTokens_updates!]!
  ): [authRefreshTokens_mutation_response]

  """
  update multiples rows of table: "auth.roles"
  """
  update_authRoles_many(
    """updates to execute, in order"""
    updates: [authRoles_updates!]!
  ): [authRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_providers"
  """
  update_authUserProviders_many(
    """updates to execute, in order"""
    updates: [authUserProviders_updates!]!
  ): [authUserProviders_mutation_response]

  """
  update multiples rows of table: "auth.user_roles"
  """
  update_authUserRoles_many(
    """updates to execute, in order"""
    updates: [authUserRoles_updates!]!
  ): [authUserRoles_mutation_response]

  """
  update multiples rows of table: "auth.user_security_keys"
  """
  update_authUserSecurityKeys_many(
    """updates to execute, in order"""
    updates: [authUserSecurityKeys_updates!]!
  ): [authUserSecurityKeys_mutation_response]

  """
  update multiples rows of table: "storage.buckets"
  """
  update_buckets_many(
    """updates to execute, in order"""
    updates: [buckets_updates!]!
  ): [buckets_mutation_response]

  """
  update data of the table: "catches"
  """
  update_catches(
    """increments the numeric columns with given value of the filtered values"""
    _inc: catches_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: catches_set_input

    """filter the rows which have to be updated"""
    where: catches_bool_exp!
  ): catches_mutation_response

  """
  update single row of the table: "catches"
  """
  update_catches_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: catches_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: catches_set_input
    pk_columns: catches_pk_columns_input!
  ): catches

  """
  update multiples rows of table: "catches"
  """
  update_catches_many(
    """updates to execute, in order"""
    updates: [catches_updates!]!
  ): [catches_mutation_response]

  """
  update data of the table: "club_documents"
  """
  update_club_documents(
    """increments the numeric columns with given value of the filtered values"""
    _inc: club_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: club_documents_set_input

    """filter the rows which have to be updated"""
    where: club_documents_bool_exp!
  ): club_documents_mutation_response

  """
  update single row of the table: "club_documents"
  """
  update_club_documents_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: club_documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: club_documents_set_input
    pk_columns: club_documents_pk_columns_input!
  ): club_documents

  """
  update multiples rows of table: "club_documents"
  """
  update_club_documents_many(
    """updates to execute, in order"""
    updates: [club_documents_updates!]!
  ): [club_documents_mutation_response]

  """
  update data of the table: "club_feed"
  """
  update_club_feed(
    """sets the columns of the filtered rows to the given values"""
    _set: club_feed_set_input

    """filter the rows which have to be updated"""
    where: club_feed_bool_exp!
  ): club_feed_mutation_response

  """
  update single row of the table: "club_feed"
  """
  update_club_feed_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: club_feed_set_input
    pk_columns: club_feed_pk_columns_input!
  ): club_feed

  """
  update data of the table: "club_feed_comments"
  """
  update_club_feed_comments(
    """sets the columns of the filtered rows to the given values"""
    _set: club_feed_comments_set_input

    """filter the rows which have to be updated"""
    where: club_feed_comments_bool_exp!
  ): club_feed_comments_mutation_response

  """
  update single row of the table: "club_feed_comments"
  """
  update_club_feed_comments_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: club_feed_comments_set_input
    pk_columns: club_feed_comments_pk_columns_input!
  ): club_feed_comments

  """
  update multiples rows of table: "club_feed_comments"
  """
  update_club_feed_comments_many(
    """updates to execute, in order"""
    updates: [club_feed_comments_updates!]!
  ): [club_feed_comments_mutation_response]

  """
  update data of the table: "club_feed_likes"
  """
  update_club_feed_likes(
    """sets the columns of the filtered rows to the given values"""
    _set: club_feed_likes_set_input

    """filter the rows which have to be updated"""
    where: club_feed_likes_bool_exp!
  ): club_feed_likes_mutation_response

  """
  update single row of the table: "club_feed_likes"
  """
  update_club_feed_likes_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: club_feed_likes_set_input
    pk_columns: club_feed_likes_pk_columns_input!
  ): club_feed_likes

  """
  update multiples rows of table: "club_feed_likes"
  """
  update_club_feed_likes_many(
    """updates to execute, in order"""
    updates: [club_feed_likes_updates!]!
  ): [club_feed_likes_mutation_response]

  """
  update multiples rows of table: "club_feed"
  """
  update_club_feed_many(
    """updates to execute, in order"""
    updates: [club_feed_updates!]!
  ): [club_feed_mutation_response]

  """
  update data of the table: "club_waters"
  """
  update_club_waters(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: club_waters_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: club_waters_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: club_waters_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: club_waters_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: club_waters_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: club_waters_set_input

    """filter the rows which have to be updated"""
    where: club_waters_bool_exp!
  ): club_waters_mutation_response

  """
  update single row of the table: "club_waters"
  """
  update_club_waters_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: club_waters_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: club_waters_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from
    the end). throws an error if top level container is not an array
    """
    _delete_elem: club_waters_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: club_waters_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: club_waters_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: club_waters_set_input
    pk_columns: club_waters_pk_columns_input!
  ): club_waters

  """
  update multiples rows of table: "club_waters"
  """
  update_club_waters_many(
    """updates to execute, in order"""
    updates: [club_waters_updates!]!
  ): [club_waters_mutation_response]

  """
  update data of the table: "clubs"
  """
  update_clubs(
    """increments the numeric columns with given value of the filtered values"""
    _inc: clubs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: clubs_set_input

    """filter the rows which have to be updated"""
    where: clubs_bool_exp!
  ): clubs_mutation_response

  """
  update single row of the table: "clubs"
  """
  update_clubs_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: clubs_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: clubs_set_input
    pk_columns: clubs_pk_columns_input!
  ): clubs

  """
  update multiples rows of table: "clubs"
  """
  update_clubs_many(
    """updates to execute, in order"""
    updates: [clubs_updates!]!
  ): [clubs_mutation_response]

  """
  update data of the table: "documents"
  """
  update_documents(
    """increments the numeric columns with given value of the filtered values"""
    _inc: documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: documents_set_input

    """filter the rows which have to be updated"""
    where: documents_bool_exp!
  ): documents_mutation_response

  """
  update single row of the table: "documents"
  """
  update_documents_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: documents_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: documents_set_input
    pk_columns: documents_pk_columns_input!
  ): documents

  """
  update multiples rows of table: "documents"
  """
  update_documents_many(
    """updates to execute, in order"""
    updates: [documents_updates!]!
  ): [documents_mutation_response]

  """
  update multiples rows of table: "storage.files"
  """
  update_files_many(
    """updates to execute, in order"""
    updates: [files_updates!]!
  ): [files_mutation_response]

  """
  update data of the table: "fishing_days"
  """
  update_fishing_days(
    """sets the columns of the filtered rows to the given values"""
    _set: fishing_days_set_input

    """filter the rows which have to be updated"""
    where: fishing_days_bool_exp!
  ): fishing_days_mutation_response

  """
  update single row of the table: "fishing_days"
  """
  update_fishing_days_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: fishing_days_set_input
    pk_columns: fishing_days_pk_columns_input!
  ): fishing_days

  """
  update multiples rows of table: "fishing_days"
  """
  update_fishing_days_many(
    """updates to execute, in order"""
    updates: [fishing_days_updates!]!
  ): [fishing_days_mutation_response]

  """
  update data of the table: "reports"
  """
  update_reports(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input

    """filter the rows which have to be updated"""
    where: reports_bool_exp!
  ): reports_mutation_response

  """
  update single row of the table: "reports"
  """
  update_reports_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: reports_set_input
    pk_columns: reports_pk_columns_input!
  ): reports

  """
  update multiples rows of table: "reports"
  """
  update_reports_many(
    """updates to execute, in order"""
    updates: [reports_updates!]!
  ): [reports_mutation_response]

  """
  update data of the table: "user_club_relation"
  """
  update_user_club_relation(
    """sets the columns of the filtered rows to the given values"""
    _set: user_club_relation_set_input

    """filter the rows which have to be updated"""
    where: user_club_relation_bool_exp!
  ): user_club_relation_mutation_response

  """
  update single row of the table: "user_club_relation"
  """
  update_user_club_relation_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: user_club_relation_set_input
    pk_columns: user_club_relation_pk_columns_input!
  ): user_club_relation

  """
  update multiples rows of table: "user_club_relation"
  """
  update_user_club_relation_many(
    """updates to execute, in order"""
    updates: [user_club_relation_updates!]!
  ): [user_club_relation_mutation_response]

  """
  update data of the table: "user_created_at"
  """
  update_user_created_at(
    """sets the columns of the filtered rows to the given values"""
    _set: user_created_at_set_input

    """filter the rows which have to be updated"""
    where: user_created_at_bool_exp!
  ): user_created_at_mutation_response

  """
  update multiples rows of table: "user_created_at"
  """
  update_user_created_at_many(
    """updates to execute, in order"""
    updates: [user_created_at_updates!]!
  ): [user_created_at_mutation_response]

  """
  update multiples rows of table: "auth.users"
  """
  update_users_many(
    """updates to execute, in order"""
    updates: [users_updates!]!
  ): [users_mutation_response]

  """
  update multiples rows of table: "storage.virus"
  """
  update_virus_many(
    """updates to execute, in order"""
    updates: [virus_updates!]!
  ): [virus_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "_enumtable.document_status"
  """
  _enumtable_document_status(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_status_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_status_bool_exp
  ): [_enumtable_document_status!]!

  """
  fetch aggregated fields from the table: "_enumtable.document_status"
  """
  _enumtable_document_status_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_status_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_status_bool_exp
  ): _enumtable_document_status_aggregate!

  """
  fetch data from the table: "_enumtable.document_status" using primary key columns
  """
  _enumtable_document_status_by_pk(value: String!): _enumtable_document_status

  """
  fetch data from the table: "_enumtable.document_type"
  """
  _enumtable_document_type(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_type_bool_exp
  ): [_enumtable_document_type!]!

  """
  fetch aggregated fields from the table: "_enumtable.document_type"
  """
  _enumtable_document_type_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_type_bool_exp
  ): _enumtable_document_type_aggregate!

  """
  fetch data from the table: "_enumtable.document_type" using primary key columns
  """
  _enumtable_document_type_by_pk(value: String!): _enumtable_document_type

  """
  fetch data from the table: "_enumtable.fish_type"
  """
  _enumtable_fish_type(
    """distinct select on columns"""
    distinct_on: [_enumtable_fish_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_fish_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_fish_type_bool_exp
  ): [_enumtable_fish_type!]!

  """
  fetch aggregated fields from the table: "_enumtable.fish_type"
  """
  _enumtable_fish_type_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_fish_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_fish_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_fish_type_bool_exp
  ): _enumtable_fish_type_aggregate!

  """
  fetch data from the table: "_enumtable.fish_type" using primary key columns
  """
  _enumtable_fish_type_by_pk(type: String!): _enumtable_fish_type

  """
  fetch data from the table: "_enumtable.report_reason"
  """
  _enumtable_report_reason(
    """distinct select on columns"""
    distinct_on: [_enumtable_report_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_report_reason_order_by!]

    """filter the rows returned"""
    where: _enumtable_report_reason_bool_exp
  ): [_enumtable_report_reason!]!

  """
  fetch aggregated fields from the table: "_enumtable.report_reason"
  """
  _enumtable_report_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_report_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_report_reason_order_by!]

    """filter the rows returned"""
    where: _enumtable_report_reason_bool_exp
  ): _enumtable_report_reason_aggregate!

  """
  fetch data from the table: "_enumtable.report_reason" using primary key columns
  """
  _enumtable_report_reason_by_pk(reason: String!): _enumtable_report_reason

  """
  fetch data from the table: "_enumtable.user_club_role"
  """
  _enumtable_user_club_role(
    """distinct select on columns"""
    distinct_on: [_enumtable_user_club_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_user_club_role_order_by!]

    """filter the rows returned"""
    where: _enumtable_user_club_role_bool_exp
  ): [_enumtable_user_club_role!]!

  """
  fetch aggregated fields from the table: "_enumtable.user_club_role"
  """
  _enumtable_user_club_role_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_user_club_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_user_club_role_order_by!]

    """filter the rows returned"""
    where: _enumtable_user_club_role_bool_exp
  ): _enumtable_user_club_role_aggregate!

  """
  fetch data from the table: "_enumtable.user_club_role" using primary key columns
  """
  _enumtable_user_club_role_by_pk(role: String!): _enumtable_user_club_role

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_token_types" using primary key columns
  """
  authRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  fetch data from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypes(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch aggregated fields from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypesAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): authRefreshTokenTypes_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """An array relationship"""
  catches(
    """distinct select on columns"""
    distinct_on: [catches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [catches_order_by!]

    """filter the rows returned"""
    where: catches_bool_exp
  ): [catches!]!

  """An aggregate relationship"""
  catches_aggregate(
    """distinct select on columns"""
    distinct_on: [catches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [catches_order_by!]

    """filter the rows returned"""
    where: catches_bool_exp
  ): catches_aggregate!

  """fetch data from the table: "catches" using primary key columns"""
  catches_by_pk(id: uuid!): catches

  """An array relationship"""
  club_documents(
    """distinct select on columns"""
    distinct_on: [club_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_documents_order_by!]

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): [club_documents!]!

  """An aggregate relationship"""
  club_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [club_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_documents_order_by!]

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): club_documents_aggregate!

  """fetch data from the table: "club_documents" using primary key columns"""
  club_documents_by_pk(id: uuid!): club_documents

  """
  fetch data from the table: "club_feed"
  """
  club_feed(
    """distinct select on columns"""
    distinct_on: [club_feed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_order_by!]

    """filter the rows returned"""
    where: club_feed_bool_exp
  ): [club_feed!]!

  """
  fetch aggregated fields from the table: "club_feed"
  """
  club_feed_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_order_by!]

    """filter the rows returned"""
    where: club_feed_bool_exp
  ): club_feed_aggregate!

  """fetch data from the table: "club_feed" using primary key columns"""
  club_feed_by_pk(id: uuid!): club_feed

  """
  fetch data from the table: "club_feed_comments"
  """
  club_feed_comments(
    """distinct select on columns"""
    distinct_on: [club_feed_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_comments_order_by!]

    """filter the rows returned"""
    where: club_feed_comments_bool_exp
  ): [club_feed_comments!]!

  """
  fetch aggregated fields from the table: "club_feed_comments"
  """
  club_feed_comments_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_comments_order_by!]

    """filter the rows returned"""
    where: club_feed_comments_bool_exp
  ): club_feed_comments_aggregate!

  """
  fetch data from the table: "club_feed_comments" using primary key columns
  """
  club_feed_comments_by_pk(id: uuid!): club_feed_comments

  """
  fetch data from the table: "club_feed_image_mapping"
  """
  club_feed_image_mapping(
    """distinct select on columns"""
    distinct_on: [club_feed_image_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_image_mapping_order_by!]

    """filter the rows returned"""
    where: club_feed_image_mapping_bool_exp
  ): [club_feed_image_mapping!]!

  """
  fetch aggregated fields from the table: "club_feed_image_mapping"
  """
  club_feed_image_mapping_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_image_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_image_mapping_order_by!]

    """filter the rows returned"""
    where: club_feed_image_mapping_bool_exp
  ): club_feed_image_mapping_aggregate!

  """
  fetch data from the table: "club_feed_likes"
  """
  club_feed_likes(
    """distinct select on columns"""
    distinct_on: [club_feed_likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_likes_order_by!]

    """filter the rows returned"""
    where: club_feed_likes_bool_exp
  ): [club_feed_likes!]!

  """
  fetch aggregated fields from the table: "club_feed_likes"
  """
  club_feed_likes_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_likes_order_by!]

    """filter the rows returned"""
    where: club_feed_likes_bool_exp
  ): club_feed_likes_aggregate!

  """fetch data from the table: "club_feed_likes" using primary key columns"""
  club_feed_likes_by_pk(reaction_id: uuid!, user_id: uuid!): club_feed_likes

  """
  fetch data from the table: "club_user_counts"
  """
  club_user_counts(
    """distinct select on columns"""
    distinct_on: [club_user_counts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_user_counts_order_by!]

    """filter the rows returned"""
    where: club_user_counts_bool_exp
  ): [club_user_counts!]!

  """
  fetch aggregated fields from the table: "club_user_counts"
  """
  club_user_counts_aggregate(
    """distinct select on columns"""
    distinct_on: [club_user_counts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_user_counts_order_by!]

    """filter the rows returned"""
    where: club_user_counts_bool_exp
  ): club_user_counts_aggregate!

  """
  fetch data from the table: "club_waters"
  """
  club_waters(
    """distinct select on columns"""
    distinct_on: [club_waters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_waters_order_by!]

    """filter the rows returned"""
    where: club_waters_bool_exp
  ): [club_waters!]!

  """
  fetch aggregated fields from the table: "club_waters"
  """
  club_waters_aggregate(
    """distinct select on columns"""
    distinct_on: [club_waters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_waters_order_by!]

    """filter the rows returned"""
    where: club_waters_bool_exp
  ): club_waters_aggregate!

  """fetch data from the table: "club_waters" using primary key columns"""
  club_waters_by_pk(id: uuid!): club_waters

  """
  fetch data from the table: "clubs"
  """
  clubs(
    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): [clubs!]!

  """
  fetch aggregated fields from the table: "clubs"
  """
  clubs_aggregate(
    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): clubs_aggregate!

  """fetch data from the table: "clubs" using primary key columns"""
  clubs_by_pk(id: uuid!): clubs

  """
  execute function "clubs_nearby" which returns "clubs"
  """
  clubs_nearby(
    """
    input parameters for function "clubs_nearby"
    """
    args: clubs_nearby_args!

    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): [clubs!]!

  """
  execute function "clubs_nearby" and query aggregates on result of table type "clubs"
  """
  clubs_nearby_aggregate(
    """
    input parameters for function "clubs_nearby_aggregate"
    """
    args: clubs_nearby_args!

    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): clubs_aggregate!

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!

  """fetch data from the table: "documents" using primary key columns"""
  documents_by_pk(id: uuid!): documents

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table: "fishing_days"
  """
  fishing_days(
    """distinct select on columns"""
    distinct_on: [fishing_days_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fishing_days_order_by!]

    """filter the rows returned"""
    where: fishing_days_bool_exp
  ): [fishing_days!]!

  """
  fetch aggregated fields from the table: "fishing_days"
  """
  fishing_days_aggregate(
    """distinct select on columns"""
    distinct_on: [fishing_days_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fishing_days_order_by!]

    """filter the rows returned"""
    where: fishing_days_bool_exp
  ): fishing_days_aggregate!

  """fetch data from the table: "fishing_days" using primary key columns"""
  fishing_days_by_pk(id: uuid!): fishing_days

  """getClubFeed"""
  getClubFeed(date_time: timestamptz!, limit_count: Int, offset_count: Int, user_id: uuid): [ClubFeedOutput!]!

  """getClubFeedComments"""
  getClubFeedComments(date_time: timestamptz!, limit_count: Int, offset_count: Int, order_by: String!, post_id: uuid!): [ClubFeedComments!]!
  getClubUsers(clubId: uuid!, limit: Int!, offset: Int!, orderBy: [ClubUserOrderByEnum!], pending: Boolean, search: String): GetClubMembersOutput!

  """
  fetch data from the table: "reports"
  """
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch aggregated fields from the table: "reports"
  """
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(id: uuid!): reports

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "user_club_relation"
  """
  user_club_relation(
    """distinct select on columns"""
    distinct_on: [user_club_relation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_club_relation_order_by!]

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): [user_club_relation!]!

  """
  fetch aggregated fields from the table: "user_club_relation"
  """
  user_club_relation_aggregate(
    """distinct select on columns"""
    distinct_on: [user_club_relation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_club_relation_order_by!]

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): user_club_relation_aggregate!

  """
  fetch data from the table: "user_club_relation" using primary key columns
  """
  user_club_relation_by_pk(id: uuid!): user_club_relation

  """
  fetch data from the table: "user_created_at"
  """
  user_created_at(
    """distinct select on columns"""
    distinct_on: [user_created_at_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_created_at_order_by!]

    """filter the rows returned"""
    where: user_created_at_bool_exp
  ): [user_created_at!]!

  """
  fetch aggregated fields from the table: "user_created_at"
  """
  user_created_at_aggregate(
    """distinct select on columns"""
    distinct_on: [user_created_at_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_created_at_order_by!]

    """filter the rows returned"""
    where: user_created_at_bool_exp
  ): user_created_at_aggregate!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "storage.virus" using primary key columns"""
  virus(id: uuid!): virus

  """
  fetch data from the table: "storage.virus"
  """
  viruses(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch aggregated fields from the table: "storage.virus"
  """
  virusesAggregate(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): virus_aggregate!
}

"""
columns and relationships of "reports"
"""
type reports {
  id: uuid!
  reportDetails: String
  reportReason: _enumtable_report_reason_enum!
  reportedId: uuid!

  """An object relationship"""
  reported_feed: club_feed
}

"""
aggregated selection of "reports"
"""
type reports_aggregate {
  aggregate: reports_aggregate_fields
  nodes: [reports!]!
}

"""
aggregate fields of "reports"
"""
type reports_aggregate_fields {
  count(columns: [reports_select_column!], distinct: Boolean): Int!
  max: reports_max_fields
  min: reports_min_fields
}

"""
Boolean expression to filter rows from the table "reports". All fields are combined with a logical 'AND'.
"""
input reports_bool_exp {
  _and: [reports_bool_exp!]
  _not: reports_bool_exp
  _or: [reports_bool_exp!]
  id: uuid_comparison_exp
  reportDetails: String_comparison_exp
  reportReason: _enumtable_report_reason_enum_comparison_exp
  reportedId: uuid_comparison_exp
  reported_feed: club_feed_bool_exp
}

"""
unique or primary key constraints on table "reports"
"""
enum reports_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  reports_pkey
}

"""
input type for inserting data into table "reports"
"""
input reports_insert_input {
  id: uuid
  reportDetails: String
  reportReason: _enumtable_report_reason_enum
  reportedId: uuid
  reported_feed: club_feed_obj_rel_insert_input
}

"""aggregate max on columns"""
type reports_max_fields {
  id: uuid
  reportDetails: String
  reportedId: uuid
}

"""aggregate min on columns"""
type reports_min_fields {
  id: uuid
  reportDetails: String
  reportedId: uuid
}

"""
response of any mutation on the table "reports"
"""
type reports_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reports!]!
}

"""
on_conflict condition type for table "reports"
"""
input reports_on_conflict {
  constraint: reports_constraint!
  update_columns: [reports_update_column!]! = []
  where: reports_bool_exp
}

"""Ordering options when selecting data from "reports"."""
input reports_order_by {
  id: order_by
  reportDetails: order_by
  reportReason: order_by
  reportedId: order_by
  reported_feed: club_feed_order_by
}

"""primary key columns input for table: reports"""
input reports_pk_columns_input {
  id: uuid!
}

"""
select columns of table "reports"
"""
enum reports_select_column {
  """column name"""
  id

  """column name"""
  reportDetails

  """column name"""
  reportReason

  """column name"""
  reportedId
}

"""
input type for updating data in table "reports"
"""
input reports_set_input {
  id: uuid
  reportDetails: String
  reportReason: _enumtable_report_reason_enum
  reportedId: uuid
}

"""
Streaming cursor of the table "reports"
"""
input reports_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reports_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reports_stream_cursor_value_input {
  id: uuid
  reportDetails: String
  reportReason: _enumtable_report_reason_enum
  reportedId: uuid
}

"""
update columns of table "reports"
"""
enum reports_update_column {
  """column name"""
  id

  """column name"""
  reportDetails

  """column name"""
  reportReason

  """column name"""
  reportedId
}

input reports_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: reports_set_input

  """filter the rows which have to be updated"""
  where: reports_bool_exp!
}

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [String!]

  """does the array contain the given value"""
  _contains: [String!]
  _eq: [String!]
  _gt: [String!]
  _gte: [String!]
  _in: [[String!]!]
  _is_null: Boolean
  _lt: [String!]
  _lte: [String!]
  _neq: [String!]
  _nin: [[String!]!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

type subscription_root {
  """
  fetch data from the table: "_enumtable.document_status"
  """
  _enumtable_document_status(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_status_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_status_bool_exp
  ): [_enumtable_document_status!]!

  """
  fetch aggregated fields from the table: "_enumtable.document_status"
  """
  _enumtable_document_status_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_status_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_status_bool_exp
  ): _enumtable_document_status_aggregate!

  """
  fetch data from the table: "_enumtable.document_status" using primary key columns
  """
  _enumtable_document_status_by_pk(value: String!): _enumtable_document_status

  """
  fetch data from the table in a streaming manner: "_enumtable.document_status"
  """
  _enumtable_document_status_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [_enumtable_document_status_stream_cursor_input]!

    """filter the rows returned"""
    where: _enumtable_document_status_bool_exp
  ): [_enumtable_document_status!]!

  """
  fetch data from the table: "_enumtable.document_type"
  """
  _enumtable_document_type(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_type_bool_exp
  ): [_enumtable_document_type!]!

  """
  fetch aggregated fields from the table: "_enumtable.document_type"
  """
  _enumtable_document_type_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_document_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_document_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_document_type_bool_exp
  ): _enumtable_document_type_aggregate!

  """
  fetch data from the table: "_enumtable.document_type" using primary key columns
  """
  _enumtable_document_type_by_pk(value: String!): _enumtable_document_type

  """
  fetch data from the table in a streaming manner: "_enumtable.document_type"
  """
  _enumtable_document_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [_enumtable_document_type_stream_cursor_input]!

    """filter the rows returned"""
    where: _enumtable_document_type_bool_exp
  ): [_enumtable_document_type!]!

  """
  fetch data from the table: "_enumtable.fish_type"
  """
  _enumtable_fish_type(
    """distinct select on columns"""
    distinct_on: [_enumtable_fish_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_fish_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_fish_type_bool_exp
  ): [_enumtable_fish_type!]!

  """
  fetch aggregated fields from the table: "_enumtable.fish_type"
  """
  _enumtable_fish_type_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_fish_type_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_fish_type_order_by!]

    """filter the rows returned"""
    where: _enumtable_fish_type_bool_exp
  ): _enumtable_fish_type_aggregate!

  """
  fetch data from the table: "_enumtable.fish_type" using primary key columns
  """
  _enumtable_fish_type_by_pk(type: String!): _enumtable_fish_type

  """
  fetch data from the table in a streaming manner: "_enumtable.fish_type"
  """
  _enumtable_fish_type_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [_enumtable_fish_type_stream_cursor_input]!

    """filter the rows returned"""
    where: _enumtable_fish_type_bool_exp
  ): [_enumtable_fish_type!]!

  """
  fetch data from the table: "_enumtable.report_reason"
  """
  _enumtable_report_reason(
    """distinct select on columns"""
    distinct_on: [_enumtable_report_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_report_reason_order_by!]

    """filter the rows returned"""
    where: _enumtable_report_reason_bool_exp
  ): [_enumtable_report_reason!]!

  """
  fetch aggregated fields from the table: "_enumtable.report_reason"
  """
  _enumtable_report_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_report_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_report_reason_order_by!]

    """filter the rows returned"""
    where: _enumtable_report_reason_bool_exp
  ): _enumtable_report_reason_aggregate!

  """
  fetch data from the table: "_enumtable.report_reason" using primary key columns
  """
  _enumtable_report_reason_by_pk(reason: String!): _enumtable_report_reason

  """
  fetch data from the table in a streaming manner: "_enumtable.report_reason"
  """
  _enumtable_report_reason_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [_enumtable_report_reason_stream_cursor_input]!

    """filter the rows returned"""
    where: _enumtable_report_reason_bool_exp
  ): [_enumtable_report_reason!]!

  """
  fetch data from the table: "_enumtable.user_club_role"
  """
  _enumtable_user_club_role(
    """distinct select on columns"""
    distinct_on: [_enumtable_user_club_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_user_club_role_order_by!]

    """filter the rows returned"""
    where: _enumtable_user_club_role_bool_exp
  ): [_enumtable_user_club_role!]!

  """
  fetch aggregated fields from the table: "_enumtable.user_club_role"
  """
  _enumtable_user_club_role_aggregate(
    """distinct select on columns"""
    distinct_on: [_enumtable_user_club_role_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [_enumtable_user_club_role_order_by!]

    """filter the rows returned"""
    where: _enumtable_user_club_role_bool_exp
  ): _enumtable_user_club_role_aggregate!

  """
  fetch data from the table: "_enumtable.user_club_role" using primary key columns
  """
  _enumtable_user_club_role_by_pk(role: String!): _enumtable_user_club_role

  """
  fetch data from the table in a streaming manner: "_enumtable.user_club_role"
  """
  _enumtable_user_club_role_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [_enumtable_user_club_role_stream_cursor_input]!

    """filter the rows returned"""
    where: _enumtable_user_club_role_bool_exp
  ): [_enumtable_user_club_role!]!

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.provider_requests"
  """
  authProviderRequests_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviderRequests_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.providers"
  """
  authProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(id: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_token_types" using primary key columns
  """
  authRefreshTokenType(value: String!): authRefreshTokenTypes

  """
  fetch data from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypes(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch aggregated fields from the table: "auth.refresh_token_types"
  """
  authRefreshTokenTypesAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokenTypes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokenTypes_order_by!]

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): authRefreshTokenTypes_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_token_types"
  """
  authRefreshTokenTypes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokenTypes_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokenTypes_bool_exp
  ): [authRefreshTokenTypes!]!

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.refresh_tokens"
  """
  authRefreshTokens_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRefreshTokens_stream_cursor_input]!

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.roles"
  """
  authRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_providers"
  """
  authUserProviders_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserProviders_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_roles"
  """
  authUserRoles_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserRoles_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch data from the table: "auth.user_security_keys" using primary key columns
  """
  authUserSecurityKey(id: uuid!): authUserSecurityKeys

  """
  fetch data from the table: "auth.user_security_keys"
  """
  authUserSecurityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """
  fetch aggregated fields from the table: "auth.user_security_keys"
  """
  authUserSecurityKeysAggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.user_security_keys"
  """
  authUserSecurityKeys_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [authUserSecurityKeys_stream_cursor_input]!

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.buckets"
  """
  buckets_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [buckets_stream_cursor_input]!

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """An array relationship"""
  catches(
    """distinct select on columns"""
    distinct_on: [catches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [catches_order_by!]

    """filter the rows returned"""
    where: catches_bool_exp
  ): [catches!]!

  """An aggregate relationship"""
  catches_aggregate(
    """distinct select on columns"""
    distinct_on: [catches_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [catches_order_by!]

    """filter the rows returned"""
    where: catches_bool_exp
  ): catches_aggregate!

  """fetch data from the table: "catches" using primary key columns"""
  catches_by_pk(id: uuid!): catches

  """
  fetch data from the table in a streaming manner: "catches"
  """
  catches_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [catches_stream_cursor_input]!

    """filter the rows returned"""
    where: catches_bool_exp
  ): [catches!]!

  """An array relationship"""
  club_documents(
    """distinct select on columns"""
    distinct_on: [club_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_documents_order_by!]

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): [club_documents!]!

  """An aggregate relationship"""
  club_documents_aggregate(
    """distinct select on columns"""
    distinct_on: [club_documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_documents_order_by!]

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): club_documents_aggregate!

  """fetch data from the table: "club_documents" using primary key columns"""
  club_documents_by_pk(id: uuid!): club_documents

  """
  fetch data from the table in a streaming manner: "club_documents"
  """
  club_documents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_documents_stream_cursor_input]!

    """filter the rows returned"""
    where: club_documents_bool_exp
  ): [club_documents!]!

  """
  fetch data from the table: "club_feed"
  """
  club_feed(
    """distinct select on columns"""
    distinct_on: [club_feed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_order_by!]

    """filter the rows returned"""
    where: club_feed_bool_exp
  ): [club_feed!]!

  """
  fetch aggregated fields from the table: "club_feed"
  """
  club_feed_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_order_by!]

    """filter the rows returned"""
    where: club_feed_bool_exp
  ): club_feed_aggregate!

  """fetch data from the table: "club_feed" using primary key columns"""
  club_feed_by_pk(id: uuid!): club_feed

  """
  fetch data from the table: "club_feed_comments"
  """
  club_feed_comments(
    """distinct select on columns"""
    distinct_on: [club_feed_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_comments_order_by!]

    """filter the rows returned"""
    where: club_feed_comments_bool_exp
  ): [club_feed_comments!]!

  """
  fetch aggregated fields from the table: "club_feed_comments"
  """
  club_feed_comments_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_comments_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_comments_order_by!]

    """filter the rows returned"""
    where: club_feed_comments_bool_exp
  ): club_feed_comments_aggregate!

  """
  fetch data from the table: "club_feed_comments" using primary key columns
  """
  club_feed_comments_by_pk(id: uuid!): club_feed_comments

  """
  fetch data from the table in a streaming manner: "club_feed_comments"
  """
  club_feed_comments_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_feed_comments_stream_cursor_input]!

    """filter the rows returned"""
    where: club_feed_comments_bool_exp
  ): [club_feed_comments!]!

  """
  fetch data from the table: "club_feed_image_mapping"
  """
  club_feed_image_mapping(
    """distinct select on columns"""
    distinct_on: [club_feed_image_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_image_mapping_order_by!]

    """filter the rows returned"""
    where: club_feed_image_mapping_bool_exp
  ): [club_feed_image_mapping!]!

  """
  fetch aggregated fields from the table: "club_feed_image_mapping"
  """
  club_feed_image_mapping_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_image_mapping_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_image_mapping_order_by!]

    """filter the rows returned"""
    where: club_feed_image_mapping_bool_exp
  ): club_feed_image_mapping_aggregate!

  """
  fetch data from the table in a streaming manner: "club_feed_image_mapping"
  """
  club_feed_image_mapping_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_feed_image_mapping_stream_cursor_input]!

    """filter the rows returned"""
    where: club_feed_image_mapping_bool_exp
  ): [club_feed_image_mapping!]!

  """
  fetch data from the table: "club_feed_likes"
  """
  club_feed_likes(
    """distinct select on columns"""
    distinct_on: [club_feed_likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_likes_order_by!]

    """filter the rows returned"""
    where: club_feed_likes_bool_exp
  ): [club_feed_likes!]!

  """
  fetch aggregated fields from the table: "club_feed_likes"
  """
  club_feed_likes_aggregate(
    """distinct select on columns"""
    distinct_on: [club_feed_likes_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_feed_likes_order_by!]

    """filter the rows returned"""
    where: club_feed_likes_bool_exp
  ): club_feed_likes_aggregate!

  """fetch data from the table: "club_feed_likes" using primary key columns"""
  club_feed_likes_by_pk(reaction_id: uuid!, user_id: uuid!): club_feed_likes

  """
  fetch data from the table in a streaming manner: "club_feed_likes"
  """
  club_feed_likes_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_feed_likes_stream_cursor_input]!

    """filter the rows returned"""
    where: club_feed_likes_bool_exp
  ): [club_feed_likes!]!

  """
  fetch data from the table in a streaming manner: "club_feed"
  """
  club_feed_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_feed_stream_cursor_input]!

    """filter the rows returned"""
    where: club_feed_bool_exp
  ): [club_feed!]!

  """
  fetch data from the table: "club_user_counts"
  """
  club_user_counts(
    """distinct select on columns"""
    distinct_on: [club_user_counts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_user_counts_order_by!]

    """filter the rows returned"""
    where: club_user_counts_bool_exp
  ): [club_user_counts!]!

  """
  fetch aggregated fields from the table: "club_user_counts"
  """
  club_user_counts_aggregate(
    """distinct select on columns"""
    distinct_on: [club_user_counts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_user_counts_order_by!]

    """filter the rows returned"""
    where: club_user_counts_bool_exp
  ): club_user_counts_aggregate!

  """
  fetch data from the table in a streaming manner: "club_user_counts"
  """
  club_user_counts_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_user_counts_stream_cursor_input]!

    """filter the rows returned"""
    where: club_user_counts_bool_exp
  ): [club_user_counts!]!

  """
  fetch data from the table: "club_waters"
  """
  club_waters(
    """distinct select on columns"""
    distinct_on: [club_waters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_waters_order_by!]

    """filter the rows returned"""
    where: club_waters_bool_exp
  ): [club_waters!]!

  """
  fetch aggregated fields from the table: "club_waters"
  """
  club_waters_aggregate(
    """distinct select on columns"""
    distinct_on: [club_waters_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [club_waters_order_by!]

    """filter the rows returned"""
    where: club_waters_bool_exp
  ): club_waters_aggregate!

  """fetch data from the table: "club_waters" using primary key columns"""
  club_waters_by_pk(id: uuid!): club_waters

  """
  fetch data from the table in a streaming manner: "club_waters"
  """
  club_waters_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [club_waters_stream_cursor_input]!

    """filter the rows returned"""
    where: club_waters_bool_exp
  ): [club_waters!]!

  """
  fetch data from the table: "clubs"
  """
  clubs(
    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): [clubs!]!

  """
  fetch aggregated fields from the table: "clubs"
  """
  clubs_aggregate(
    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): clubs_aggregate!

  """fetch data from the table: "clubs" using primary key columns"""
  clubs_by_pk(id: uuid!): clubs

  """
  execute function "clubs_nearby" which returns "clubs"
  """
  clubs_nearby(
    """
    input parameters for function "clubs_nearby"
    """
    args: clubs_nearby_args!

    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): [clubs!]!

  """
  execute function "clubs_nearby" and query aggregates on result of table type "clubs"
  """
  clubs_nearby_aggregate(
    """
    input parameters for function "clubs_nearby_aggregate"
    """
    args: clubs_nearby_args!

    """distinct select on columns"""
    distinct_on: [clubs_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clubs_order_by!]

    """filter the rows returned"""
    where: clubs_bool_exp
  ): clubs_aggregate!

  """
  fetch data from the table in a streaming manner: "clubs"
  """
  clubs_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [clubs_stream_cursor_input]!

    """filter the rows returned"""
    where: clubs_bool_exp
  ): [clubs!]!

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!

  """fetch data from the table: "documents" using primary key columns"""
  documents_by_pk(id: uuid!): documents

  """
  fetch data from the table in a streaming manner: "documents"
  """
  documents_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [documents_stream_cursor_input]!

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """An array relationship"""
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table in a streaming manner: "storage.files"
  """
  files_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [files_stream_cursor_input]!

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch data from the table: "fishing_days"
  """
  fishing_days(
    """distinct select on columns"""
    distinct_on: [fishing_days_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fishing_days_order_by!]

    """filter the rows returned"""
    where: fishing_days_bool_exp
  ): [fishing_days!]!

  """
  fetch aggregated fields from the table: "fishing_days"
  """
  fishing_days_aggregate(
    """distinct select on columns"""
    distinct_on: [fishing_days_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [fishing_days_order_by!]

    """filter the rows returned"""
    where: fishing_days_bool_exp
  ): fishing_days_aggregate!

  """fetch data from the table: "fishing_days" using primary key columns"""
  fishing_days_by_pk(id: uuid!): fishing_days

  """
  fetch data from the table in a streaming manner: "fishing_days"
  """
  fishing_days_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [fishing_days_stream_cursor_input]!

    """filter the rows returned"""
    where: fishing_days_bool_exp
  ): [fishing_days!]!

  """
  fetch data from the table: "reports"
  """
  reports(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """
  fetch aggregated fields from the table: "reports"
  """
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [reports_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reports_order_by!]

    """filter the rows returned"""
    where: reports_bool_exp
  ): reports_aggregate!

  """fetch data from the table: "reports" using primary key columns"""
  reports_by_pk(id: uuid!): reports

  """
  fetch data from the table in a streaming manner: "reports"
  """
  reports_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reports_stream_cursor_input]!

    """filter the rows returned"""
    where: reports_bool_exp
  ): [reports!]!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch data from the table: "user_club_relation"
  """
  user_club_relation(
    """distinct select on columns"""
    distinct_on: [user_club_relation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_club_relation_order_by!]

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): [user_club_relation!]!

  """
  fetch aggregated fields from the table: "user_club_relation"
  """
  user_club_relation_aggregate(
    """distinct select on columns"""
    distinct_on: [user_club_relation_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_club_relation_order_by!]

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): user_club_relation_aggregate!

  """
  fetch data from the table: "user_club_relation" using primary key columns
  """
  user_club_relation_by_pk(id: uuid!): user_club_relation

  """
  fetch data from the table in a streaming manner: "user_club_relation"
  """
  user_club_relation_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_club_relation_stream_cursor_input]!

    """filter the rows returned"""
    where: user_club_relation_bool_exp
  ): [user_club_relation!]!

  """
  fetch data from the table: "user_created_at"
  """
  user_created_at(
    """distinct select on columns"""
    distinct_on: [user_created_at_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_created_at_order_by!]

    """filter the rows returned"""
    where: user_created_at_bool_exp
  ): [user_created_at!]!

  """
  fetch aggregated fields from the table: "user_created_at"
  """
  user_created_at_aggregate(
    """distinct select on columns"""
    distinct_on: [user_created_at_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_created_at_order_by!]

    """filter the rows returned"""
    where: user_created_at_bool_exp
  ): user_created_at_aggregate!

  """
  fetch data from the table in a streaming manner: "user_created_at"
  """
  user_created_at_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_created_at_stream_cursor_input]!

    """filter the rows returned"""
    where: user_created_at_bool_exp
  ): [user_created_at!]!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "auth.users"
  """
  usersAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table in a streaming manner: "auth.users"
  """
  users_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [users_stream_cursor_input]!

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """fetch data from the table: "storage.virus" using primary key columns"""
  virus(id: uuid!): virus

  """
  fetch data from the table in a streaming manner: "storage.virus"
  """
  virus_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [virus_stream_cursor_input]!

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch data from the table: "storage.virus"
  """
  viruses(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): [virus!]!

  """
  fetch aggregated fields from the table: "storage.virus"
  """
  virusesAggregate(
    """distinct select on columns"""
    distinct_on: [virus_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [virus_order_by!]

    """filter the rows returned"""
    where: virus_bool_exp
  ): virus_aggregate!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

type User {
  avatarUrl: String!
  displayName: String!
  email: String!
  id: String!
  lastSeen: timestamptz!
}

"""
columns and relationships of "user_club_relation"
"""
type user_club_relation {
  """An object relationship"""
  club: clubs!
  club_id: uuid!

  """An object relationship"""
  club_user_count_view: club_user_counts
  id: uuid!
  pending: Boolean!
  role: _enumtable_user_club_role_enum!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "user_club_relation"
"""
type user_club_relation_aggregate {
  aggregate: user_club_relation_aggregate_fields
  nodes: [user_club_relation!]!
}

input user_club_relation_aggregate_bool_exp {
  bool_and: user_club_relation_aggregate_bool_exp_bool_and
  bool_or: user_club_relation_aggregate_bool_exp_bool_or
  count: user_club_relation_aggregate_bool_exp_count
}

input user_club_relation_aggregate_bool_exp_bool_and {
  arguments: user_club_relation_select_column_user_club_relation_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: user_club_relation_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_club_relation_aggregate_bool_exp_bool_or {
  arguments: user_club_relation_select_column_user_club_relation_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: user_club_relation_bool_exp
  predicate: Boolean_comparison_exp!
}

input user_club_relation_aggregate_bool_exp_count {
  arguments: [user_club_relation_select_column!]
  distinct: Boolean
  filter: user_club_relation_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user_club_relation"
"""
type user_club_relation_aggregate_fields {
  count(columns: [user_club_relation_select_column!], distinct: Boolean): Int!
  max: user_club_relation_max_fields
  min: user_club_relation_min_fields
}

"""
order by aggregate values of table "user_club_relation"
"""
input user_club_relation_aggregate_order_by {
  count: order_by
  max: user_club_relation_max_order_by
  min: user_club_relation_min_order_by
}

"""
input type for inserting array relation for remote table "user_club_relation"
"""
input user_club_relation_arr_rel_insert_input {
  data: [user_club_relation_insert_input!]!

  """upsert condition"""
  on_conflict: user_club_relation_on_conflict
}

"""
Boolean expression to filter rows from the table "user_club_relation". All fields are combined with a logical 'AND'.
"""
input user_club_relation_bool_exp {
  _and: [user_club_relation_bool_exp!]
  _not: user_club_relation_bool_exp
  _or: [user_club_relation_bool_exp!]
  club: clubs_bool_exp
  club_id: uuid_comparison_exp
  club_user_count_view: club_user_counts_bool_exp
  id: uuid_comparison_exp
  pending: Boolean_comparison_exp
  role: _enumtable_user_club_role_enum_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "user_club_relation"
"""
enum user_club_relation_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  user_club_relation_pkey

  """
  unique or primary key constraint on columns "user_id", "club_id"
  """
  user_club_relation_user_id_club_id_key
}

"""
input type for inserting data into table "user_club_relation"
"""
input user_club_relation_insert_input {
  club: clubs_obj_rel_insert_input
  club_id: uuid
  club_user_count_view: club_user_counts_obj_rel_insert_input
  id: uuid
  pending: Boolean
  role: _enumtable_user_club_role_enum
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type user_club_relation_max_fields {
  club_id: uuid
  id: uuid
  user_id: uuid
}

"""
order by max() on columns of table "user_club_relation"
"""
input user_club_relation_max_order_by {
  club_id: order_by
  id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type user_club_relation_min_fields {
  club_id: uuid
  id: uuid
  user_id: uuid
}

"""
order by min() on columns of table "user_club_relation"
"""
input user_club_relation_min_order_by {
  club_id: order_by
  id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "user_club_relation"
"""
type user_club_relation_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_club_relation!]!
}

"""
on_conflict condition type for table "user_club_relation"
"""
input user_club_relation_on_conflict {
  constraint: user_club_relation_constraint!
  update_columns: [user_club_relation_update_column!]! = []
  where: user_club_relation_bool_exp
}

"""Ordering options when selecting data from "user_club_relation"."""
input user_club_relation_order_by {
  club: clubs_order_by
  club_id: order_by
  club_user_count_view: club_user_counts_order_by
  id: order_by
  pending: order_by
  role: order_by
  user: users_order_by
  user_id: order_by
}

"""primary key columns input for table: user_club_relation"""
input user_club_relation_pk_columns_input {
  id: uuid!
}

"""
select columns of table "user_club_relation"
"""
enum user_club_relation_select_column {
  """column name"""
  club_id

  """column name"""
  id

  """column name"""
  pending

  """column name"""
  role

  """column name"""
  user_id
}

"""
select "user_club_relation_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user_club_relation"
"""
enum user_club_relation_select_column_user_club_relation_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  pending
}

"""
select "user_club_relation_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user_club_relation"
"""
enum user_club_relation_select_column_user_club_relation_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  pending
}

"""
input type for updating data in table "user_club_relation"
"""
input user_club_relation_set_input {
  club_id: uuid
  id: uuid
  pending: Boolean
  role: _enumtable_user_club_role_enum
  user_id: uuid
}

"""
Streaming cursor of the table "user_club_relation"
"""
input user_club_relation_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_club_relation_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_club_relation_stream_cursor_value_input {
  club_id: uuid
  id: uuid
  pending: Boolean
  role: _enumtable_user_club_role_enum
  user_id: uuid
}

"""
update columns of table "user_club_relation"
"""
enum user_club_relation_update_column {
  """column name"""
  club_id

  """column name"""
  id

  """column name"""
  pending

  """column name"""
  role

  """column name"""
  user_id
}

input user_club_relation_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_club_relation_set_input

  """filter the rows which have to be updated"""
  where: user_club_relation_bool_exp!
}

"""
Eigene View damit jeder User das Beitrittsdatum aller anderen User sehen kann.
Direkt Permission auf die User zu geben ist schwierig, da es zu Permission
Konflikten kommt.
"""
type user_created_at {
  created_at: timestamptz
  user_id: uuid
}

"""
aggregated selection of "user_created_at"
"""
type user_created_at_aggregate {
  aggregate: user_created_at_aggregate_fields
  nodes: [user_created_at!]!
}

"""
aggregate fields of "user_created_at"
"""
type user_created_at_aggregate_fields {
  count(columns: [user_created_at_select_column!], distinct: Boolean): Int!
  max: user_created_at_max_fields
  min: user_created_at_min_fields
}

"""
Boolean expression to filter rows from the table "user_created_at". All fields are combined with a logical 'AND'.
"""
input user_created_at_bool_exp {
  _and: [user_created_at_bool_exp!]
  _not: user_created_at_bool_exp
  _or: [user_created_at_bool_exp!]
  created_at: timestamptz_comparison_exp
  user_id: uuid_comparison_exp
}

"""
input type for inserting data into table "user_created_at"
"""
input user_created_at_insert_input {
  created_at: timestamptz
  user_id: uuid
}

"""aggregate max on columns"""
type user_created_at_max_fields {
  created_at: timestamptz
  user_id: uuid
}

"""aggregate min on columns"""
type user_created_at_min_fields {
  created_at: timestamptz
  user_id: uuid
}

"""
response of any mutation on the table "user_created_at"
"""
type user_created_at_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_created_at!]!
}

"""Ordering options when selecting data from "user_created_at"."""
input user_created_at_order_by {
  created_at: order_by
  user_id: order_by
}

"""
select columns of table "user_created_at"
"""
enum user_created_at_select_column {
  """column name"""
  created_at

  """column name"""
  user_id
}

"""
input type for updating data in table "user_created_at"
"""
input user_created_at_set_input {
  created_at: timestamptz
  user_id: uuid
}

"""
Streaming cursor of the table "user_created_at"
"""
input user_created_at_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_created_at_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_created_at_stream_cursor_value_input {
  created_at: timestamptz
  user_id: uuid
}

input user_created_at_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: user_created_at_set_input

  """filter the rows which have to be updated"""
  where: user_created_at_bool_exp!
}

type UserClubRelation {
  role: String!
  user: User!
}

type UserClubRelationAggregate {
  aggregate: Aggregate!
}

"""
User account information. Don't modify its structure as Hasura Auth relies on it to function properly.
"""
type users {
  activeMfaType: String
  avatarUrl: String!
  createdAt: timestamptz!
  currentChallenge: String
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!

  """An array relationship"""
  documents(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): [documents!]!

  """An aggregate relationship"""
  documents_aggregate(
    """distinct select on columns"""
    distinct_on: [documents_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [documents_order_by!]

    """filter the rows returned"""
    where: documents_bool_exp
  ): documents_aggregate!
  email: citext
  emailVerified: Boolean!
  id: uuid!
  isAnonymous: Boolean!

  """
  A computed field, executes function "user_is_verified"
  """
  isVerified: Boolean
  lastSeen: timestamptz
  locale: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  securityKeys(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): [authUserSecurityKeys!]!

  """An aggregate relationship"""
  securityKeys_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserSecurityKeys_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserSecurityKeys_order_by!]

    """filter the rows returned"""
    where: authUserSecurityKeys_bool_exp
  ): authUserSecurityKeys_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

input users_aggregate_bool_exp {
  bool_and: users_aggregate_bool_exp_bool_and
  bool_or: users_aggregate_bool_exp_bool_or
  count: users_aggregate_bool_exp_count
}

input users_aggregate_bool_exp_bool_and {
  arguments: users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_bool_or {
  arguments: users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: users_bool_exp
  predicate: Boolean_comparison_exp!
}

input users_aggregate_bool_exp_count {
  arguments: [users_select_column!]
  distinct: Boolean
  filter: users_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  currentChallenge: String_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  documents: documents_bool_exp
  documents_aggregate: documents_aggregate_bool_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: uuid_comparison_exp
  isAnonymous: Boolean_comparison_exp
  isVerified: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  refreshTokens_aggregate: authRefreshTokens_aggregate_bool_exp
  roles: authUserRoles_bool_exp
  roles_aggregate: authUserRoles_aggregate_bool_exp
  securityKeys: authUserSecurityKeys_bool_exp
  securityKeys_aggregate: authUserSecurityKeys_aggregate_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
  userProviders_aggregate: authUserProviders_aggregate_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  users_email_key

  """
  unique or primary key constraint on columns "phone_number"
  """
  users_phone_number_key

  """
  unique or primary key constraint on columns "id"
  """
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  documents: documents_arr_rel_insert_input
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  securityKeys: authUserSecurityKeys_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  currentChallenge: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  documents_aggregate: documents_aggregate_order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  isAnonymous: order_by
  isVerified: order_by
  lastSeen: order_by
  locale: order_by
  metadata: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  securityKeys_aggregate: authUserSecurityKeys_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: auth.users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
select "users_aggregate_bool_exp_bool_and_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
select "users_aggregate_bool_exp_bool_or_arguments_columns" columns of table "auth.users"
"""
enum users_select_column_users_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  disabled

  """column name"""
  emailVerified

  """column name"""
  isAnonymous

  """column name"""
  phoneNumberVerified
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
Streaming cursor of the table "users"
"""
input users_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: users_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input users_stream_cursor_value_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  currentChallenge: String
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  currentChallenge

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

input users_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: users_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: users_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: users_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: users_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: users_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: users_set_input

  """filter the rows which have to be updated"""
  where: users_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_array_comparison_exp {
  """is the array contained in the given array value"""
  _contained_in: [uuid!]

  """does the array contain the given value"""
  _contains: [uuid!]
  _eq: [uuid!]
  _gt: [uuid!]
  _gte: [uuid!]
  _in: [[uuid!]!]
  _is_null: Boolean
  _lt: [uuid!]
  _lte: [uuid!]
  _neq: [uuid!]
  _nin: [[uuid!]!]
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""
columns and relationships of "storage.virus"
"""
type virus {
  createdAt: timestamptz!

  """An object relationship"""
  file: files!
  fileId: uuid!
  filename: String!
  id: uuid!
  updatedAt: timestamptz!
  userSession(
    """JSON select path"""
    path: String
  ): jsonb!
  virus: String!
}

"""
aggregated selection of "storage.virus"
"""
type virus_aggregate {
  aggregate: virus_aggregate_fields
  nodes: [virus!]!
}

"""
aggregate fields of "storage.virus"
"""
type virus_aggregate_fields {
  count(columns: [virus_select_column!], distinct: Boolean): Int!
  max: virus_max_fields
  min: virus_min_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input virus_append_input {
  userSession: jsonb
}

"""
Boolean expression to filter rows from the table "storage.virus". All fields are combined with a logical 'AND'.
"""
input virus_bool_exp {
  _and: [virus_bool_exp!]
  _not: virus_bool_exp
  _or: [virus_bool_exp!]
  createdAt: timestamptz_comparison_exp
  file: files_bool_exp
  fileId: uuid_comparison_exp
  filename: String_comparison_exp
  id: uuid_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userSession: jsonb_comparison_exp
  virus: String_comparison_exp
}

"""
unique or primary key constraints on table "storage.virus"
"""
enum virus_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  virus_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input virus_delete_at_path_input {
  userSession: [String!]
}

"""
delete the array element with specified index (negative integers count from the
end). throws an error if top level container is not an array
"""
input virus_delete_elem_input {
  userSession: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input virus_delete_key_input {
  userSession: String
}

"""
input type for inserting data into table "storage.virus"
"""
input virus_insert_input {
  createdAt: timestamptz
  file: files_obj_rel_insert_input
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""aggregate max on columns"""
type virus_max_fields {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  virus: String
}

"""aggregate min on columns"""
type virus_min_fields {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  virus: String
}

"""
response of any mutation on the table "storage.virus"
"""
type virus_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [virus!]!
}

"""
on_conflict condition type for table "storage.virus"
"""
input virus_on_conflict {
  constraint: virus_constraint!
  update_columns: [virus_update_column!]! = []
  where: virus_bool_exp
}

"""Ordering options when selecting data from "storage.virus"."""
input virus_order_by {
  createdAt: order_by
  file: files_order_by
  fileId: order_by
  filename: order_by
  id: order_by
  updatedAt: order_by
  userSession: order_by
  virus: order_by
}

"""primary key columns input for table: storage.virus"""
input virus_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input virus_prepend_input {
  userSession: jsonb
}

"""
select columns of table "storage.virus"
"""
enum virus_select_column {
  """column name"""
  createdAt

  """column name"""
  fileId

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userSession

  """column name"""
  virus
}

"""
input type for updating data in table "storage.virus"
"""
input virus_set_input {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""
Streaming cursor of the table "virus"
"""
input virus_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: virus_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input virus_stream_cursor_value_input {
  createdAt: timestamptz
  fileId: uuid
  filename: String
  id: uuid
  updatedAt: timestamptz
  userSession: jsonb
  virus: String
}

"""
update columns of table "storage.virus"
"""
enum virus_update_column {
  """column name"""
  createdAt

  """column name"""
  fileId

  """column name"""
  filename

  """column name"""
  id

  """column name"""
  updatedAt

  """column name"""
  userSession

  """column name"""
  virus
}

input virus_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: virus_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: virus_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from
  the end). throws an error if top level container is not an array
  """
  _delete_elem: virus_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: virus_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: virus_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: virus_set_input

  """filter the rows which have to be updated"""
  where: virus_bool_exp!
}

